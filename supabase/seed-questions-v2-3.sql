-- Monitoring & Observability Questions (25 questions)
-- Generated by Codex/GPT based on docs/05-monitoring-observability.md

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'observability-pillars', 1, 1, 25, '관측성 3요소인 Metrics, Logs, Traces를 각각 어떤 질문에 답하는 데이터인지 설명하세요.', 'Metrics는 시스템 상태를 수치로 보여 주어 현재 얼마나 나쁜지 빠르게 파악하게 해줍니다. Logs는 개별 이벤트의 상세 맥락을 남겨 무엇이 실제로 발생했는지 설명합니다. Traces는 요청이 여러 서비스로 이동한 경로와 지연 구간을 보여 병목 위치를 찾게 해줍니다.', ARRAY['metrics', 'logs', 'traces'], '각 신호가 답하는 질문이 다르다는 점을 이해해야 장애 분석 경로를 올바르게 잡을 수 있다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'prometheus-pull-model', 1, 1, 25, 'Prometheus가 Pull 방식으로 메트릭을 수집할 때의 동작 방식과 장점을 설명하세요.', 'Prometheus 서버가 주기적으로 대상 엔드포인트의 /metrics를 스크랩해 데이터를 가져옵니다. 수집 주기와 실패 여부를 중앙에서 통제하기 쉬워 운영 단순성이 높습니다. 또한 대상이 외부로 푸시 연결을 열 필요가 없어 보안 경계 관리가 비교적 쉽습니다.', ARRAY['prometheus', 'pull-model', 'scrape'], 'Pull 모델의 핵심은 중앙 스크랩 제어와 대상 단순화다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'grafana-dashboard-variables', 1, 1, 25, 'Grafana 대시보드 변수(templating variable)를 사용하는 이유와 운영상 이점을 설명하세요.', '변수를 쓰면 같은 패널 쿼리를 서비스, 클러스터, 환경 값으로 재사용할 수 있습니다. 대시보드 복제를 줄여 유지보수 비용과 불일치 위험을 낮춥니다. 운영자는 한 화면에서 범위를 바꿔 비교 분석을 빠르게 수행할 수 있습니다.', ARRAY['grafana', 'dashboard', 'variables'], '변수는 대시보드 재사용성과 비교 분석 속도를 동시에 개선한다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'elk-basics', 1, 1, 25, 'ELK Stack에서 Elasticsearch, Logstash, Kibana의 역할을 각각 설명하세요.', 'Logstash는 다양한 소스에서 로그를 수집하고 파싱 및 변환을 수행합니다. Elasticsearch는 색인과 검색을 담당하며 대용량 로그 조회를 빠르게 처리합니다. Kibana는 시각화와 탐색 인터페이스를 제공해 분석과 대시보드 구성을 가능하게 합니다.', ARRAY['elasticsearch', 'logstash', 'kibana'], 'ELK는 수집 변환 저장 시각화를 분리해 확장성과 유지보수를 높인다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'tracing-trace-span', 1, 1, 25, '분산 트레이싱에서 Trace와 Span의 관계를 설명하고, 병목 분석에 왜 유용한지 답하세요.', 'Trace는 하나의 요청이 시스템을 통과한 전체 여정을 나타냅니다. Span은 그 여정 안의 개별 작업 단위로 시작 시간, 종료 시간, 태그를 가집니다. Span을 시간순으로 보면 지연이 큰 구간을 정확히 찾아 병목 서비스나 외부 호출 문제를 좁힐 수 있습니다.', ARRAY['trace', 'span', 'jaeger'], 'Trace와 Span 계층을 이해하면 지연 원인을 구조적으로 찾을 수 있다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'golden-signals', 1, 1, 25, 'Golden Signals 네 가지를 쓰고, 이 지표 묶음이 서비스 모니터링의 기본이 되는 이유를 설명하세요.', 'Golden Signals는 지연시간, 트래픽, 에러, 포화도입니다. 이 네 가지는 사용자 체감 품질과 시스템 자원 한계를 동시에 보여 줍니다. 그래서 세부 내부 지표를 보기 전에 서비스 건강도를 빠르게 판단하는 공통 기준이 됩니다.', ARRAY['golden-signals', 'latency', 'saturation'], 'Golden Signals는 사용자 영향과 시스템 한계를 동시에 관찰하는 최소 집합이다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'prometheus-metric-types', 2, 10, 50, 'Counter, Gauge, Histogram, Summary의 차이를 간단히 비교하고, Histogram이 특히 유용한 상황을 설명하세요.', 'Counter는 단조 증가 값이고 Gauge는 증가와 감소가 모두 가능한 순간값입니다. Histogram은 값을 버킷으로 집계해 구간 분포와 분위수 계산에 유리하고 Summary는 클라이언트 측 분위수를 제공합니다. 서버 간 집계가 필요한 대규모 환경에서는 보통 Histogram이 더 실용적입니다.', ARRAY['counter', 'gauge', 'histogram'], '메트릭 타입 선택은 집계 가능성과 해석 정확도에 직접 영향을 준다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'promql-rate-increase', 2, 10, 50, 'PromQL의 rate()와 increase()는 어떻게 다르며 각각 언제 쓰는 것이 적절한가요.', 'rate()는 초당 평균 증가율을 반환해 시계열 비교와 알림 조건에 적합합니다. increase()는 기간 동안 누적 증가량을 반환해 총 요청 수나 총 에러 수 계산에 적합합니다. 둘 다 카운터 리셋을 보정하지만 해석 단위가 다르므로 목적에 맞게 선택해야 합니다.', ARRAY['promql', 'rate', 'increase'], 'rate와 increase는 같은 카운터 기반이지만 의미 단위가 다르다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'grafana-alerting-basics', 2, 10, 50, 'Grafana 알림에서 조건식, 평가 주기, no data 처리 정책을 분리해서 설계해야 하는 이유를 설명하세요.', '조건식은 무엇이 이상인지 정의하고 평가 주기는 얼마나 자주 검사할지 결정합니다. no data 정책을 분리하면 데이터 공백을 장애로 볼지 무시할지 명확히 통제할 수 있습니다. 이 세 요소를 분리해야 오탐과 미탐을 줄이고 팀별 운영 정책을 일관되게 유지할 수 있습니다.', ARRAY['grafana-alert', 'evaluation', 'no-data'], '알림 품질은 조건식뿐 아니라 평가 주기와 데이터 공백 정책에 좌우된다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'loki-label-logql', 2, 10, 50, 'Loki의 라벨 기반 인덱싱이 전체 로그 본문 인덱싱보다 비용에 유리한 이유와 LogQL 조회 방식의 특징을 설명하세요.', 'Loki는 라벨만 인덱싱하고 로그 본문은 객체 저장소에 두어 인덱스 비용을 크게 줄입니다. 조회 시 먼저 라벨로 스트림을 좁힌 뒤 LogQL 파이프라인으로 본문 필터와 파싱을 적용합니다. 이 구조는 고카디널리티 본문 전체 색인보다 저장 비용과 운영 복잡도가 낮습니다.', ARRAY['loki', 'labels', 'logql'], 'Loki의 비용 효율성은 라벨 인덱싱과 본문 후처리 조회 모델에서 나온다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'opentelemetry-collector-pipeline', 2, 10, 50, 'OpenTelemetry Collector의 receiver, processor, exporter 파이프라인이 필요한 이유를 설명하세요.', 'Receiver는 다양한 프로토콜에서 텔레메트리를 수집합니다. Processor는 배치, 샘플링, 속성 정규화 같은 후처리로 비용과 품질을 조정합니다. Exporter는 목적지별 형식으로 전송하여 백엔드 교체와 다중 전송을 유연하게 만듭니다.', ARRAY['opentelemetry', 'collector', 'pipeline'], 'Collector 파이프라인 분리는 표준화와 벤더 독립성을 높인다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'elasticsearch-ilm', 2, 10, 50, 'Elasticsearch ILM에서 hot, warm, cold, delete 단계의 목적을 설명하고 로그 보관 정책과 연결하세요.', 'Hot 단계는 최근 데이터를 빠르게 쓰고 자주 조회하도록 최적화합니다. Warm과 cold 단계는 조회 빈도에 맞춰 비용 효율적인 저장 계층으로 이동합니다. 마지막 delete 단계로 보존 기간이 끝난 데이터를 자동 제거해 스토리지 비용과 규정 준수를 함께 관리합니다.', ARRAY['elasticsearch', 'ilm', 'retention'], 'ILM은 성능과 비용과 보존 요구사항을 단계별로 균형화한다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'sli-slo-sla', 2, 10, 50, 'SLI, SLO, SLA의 차이와 에러 버짓의 관계를 설명하세요.', 'SLI는 실제 서비스 품질을 측정하는 지표이고 SLO는 그 지표에 대한 목표 수준입니다. SLA는 계약상 약속으로 미준수 시 보상 조건이 뒤따를 수 있습니다. 에러 버짓은 SLO에서 허용되는 실패 여유분이며 배포 속도와 안정성의 균형 기준으로 쓰입니다.', ARRAY['sli', 'slo', 'sla'], 'SLI SLO SLA와 에러 버짓 관계는 신뢰성 운영의 핵심 언어다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'alert-grouping-inhibition', 2, 10, 50, '알림 시스템에서 그룹화(grouping)와 억제(inhibition)를 적용하면 어떤 운영 문제가 줄어드는지 설명하세요.', '그룹화는 같은 원인에서 발생한 다수 알림을 하나로 묶어 알림 폭주를 줄입니다. 억제는 상위 장애가 발생했을 때 파생 알림을 잠시 막아 우선순위를 명확히 합니다. 두 기법을 함께 쓰면 온콜 피로도를 낮추고 실제 근본 원인 대응 시간을 단축할 수 있습니다.', ARRAY['alerting', 'grouping', 'inhibition'], '그룹화와 억제는 알림 피로도를 줄이는 대표적 운영 기법이다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'error-budget-policy', 3, 30, 75, '에러 버짓 소진율을 배포 의사결정에 연결하는 운영 정책을 설계할 때 핵심 원칙을 설명하세요.', '에러 버짓 소진율이 낮을 때는 기능 배포를 가속하고 소진율이 높을 때는 안정화 작업을 우선합니다. 정책은 임계치와 조치 단계를 사전에 명문화해 팀 간 해석 차이를 없애야 합니다. 이렇게 하면 가용성 목표를 지키면서도 제품 출시 속도를 데이터 기반으로 조절할 수 있습니다.', ARRAY['error-budget', 'release-policy', 'reliability'], '에러 버짓 기반 정책은 안정성과 출시 속도를 동시에 관리하게 한다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'prometheus-histogram-quantile', 3, 30, 75, 'Prometheus에서 histogram_quantile()로 지연시간 p95를 계산할 때 버킷 설계가 결과 정확도에 미치는 영향을 설명하세요.', 'histogram_quantile() 정확도는 버킷 경계의 촘촘함과 분포 적합성에 크게 좌우됩니다. 지연 분포가 급격히 변하는 구간에 버킷이 성기면 p95가 과대 또는 과소 추정될 수 있습니다. 서비스 특성에 맞는 버킷 설계와 주기적 재평가가 필수입니다.', ARRAY['histogram_quantile', 'prometheus', 'latency'], '분위수 정확도는 수집 쿼리보다 버킷 설계의 영향을 크게 받는다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'distributed-tracing-context', 3, 30, 75, 'Jaeger 또는 Zipkin 기반 분산 트레이싱에서 컨텍스트 전파가 끊기면 어떤 문제가 생기며 어떻게 예방하나요.', '컨텍스트 전파가 끊기면 같은 사용자 요청이 여러 개의 독립 Trace로 분리되어 원인 추적이 어려워집니다. 특히 비동기 큐나 외부 API 경계에서 trace id 전달 누락이 자주 발생합니다. W3C Trace Context 헤더 전파를 공통 미들웨어로 강제하면 대부분 예방할 수 있습니다.', ARRAY['trace-context', 'jaeger', 'zipkin'], '컨텍스트 전파 표준화는 분산 트레이싱 신뢰도를 결정한다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'log-collection-pipeline', 3, 30, 75, '로그 수집 파이프라인에서 수집 에이전트, 큐, 저장소를 분리하는 아키텍처가 필요한 이유를 설명하세요.', '수집 에이전트와 중앙 큐를 분리하면 일시적 네트워크 장애에도 로그 유실을 줄일 수 있습니다. 큐는 버퍼와 재시도를 제공해 다운스트림 저장소 부하 급증을 흡수합니다. 저장소를 분리하면 보존 정책과 검색 성능을 독립적으로 최적화할 수 있습니다.', ARRAY['log-pipeline', 'buffer', 'backpressure'], '파이프라인 단계 분리는 유실 방지와 확장성 확보를 위한 기본 설계다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'apm-signal-correlation', 3, 30, 75, 'APM에서 트랜잭션 지연 원인을 찾을 때 메트릭, 트레이스, 로그를 상호 연계해야 하는 이유를 설명하세요.', '메트릭은 이상 징후를 빠르게 감지하지만 원인 세부 맥락은 부족할 수 있습니다. 트레이스는 병목 구간을 보여 주고 로그는 해당 구간의 오류 메시지와 입력 조건을 제공합니다. 세 신호를 트랜잭션 id나 trace id로 연결해야 재현 없이 근본 원인에 도달할 확률이 높아집니다.', ARRAY['apm', 'trace-id', 'root-cause'], '신호 연계 없이는 탐지와 원인 분석 사이 전환 비용이 커진다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'use-method-analysis', 3, 30, 75, 'USE Method를 사용해 노드 성능 병목을 분석하는 절차를 CPU와 디스크 예시로 설명하세요.', 'USE Method는 각 자원에 대해 사용률, 포화도, 오류율을 순서대로 점검합니다. CPU는 높은 사용률과 런큐 길이로 포화 여부를, 디스크는 대기열 길이와 IOPS 오류로 병목 여부를 확인합니다. 동일 프레임으로 모든 자원을 비교하면 분석 누락 없이 우선순위를 정하기 쉽습니다.', ARRAY['use-method', 'utilization', 'saturation'], 'USE는 자원 병목 분석을 체계화해 누락을 줄인다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'anomaly-detection-baseline', 3, 30, 75, '이상 탐지에서 고정 임계치 대신 계절성 기반 동적 기준선을 쓰는 장점과 주의점을 설명하세요.', '동적 기준선은 시간대와 요일 패턴을 반영해 정상 변동을 이상으로 오인하는 비율을 줄입니다. 특히 트래픽이 주기적으로 변하는 서비스에서 고정 임계치보다 탐지 품질이 높습니다. 다만 기준선 학습 구간에 장애 데이터가 섞이지 않도록 데이터 정제가 필요합니다.', ARRAY['anomaly-detection', 'baseline', 'seasonality'], '동적 기준선은 정상 패턴을 학습해 오탐을 줄이지만 학습 데이터 품질이 중요하다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'slo-burn-rate-alerting', 4, 50, 100, '다중 윈도우 burn rate 알림을 SLO 기반으로 설계할 때 짧은 창과 긴 창을 함께 쓰는 이유를 설명하세요.', '짧은 창은 급격한 장애를 빠르게 포착하고 긴 창은 지속적 품질 저하를 안정적으로 감지합니다. 두 창에서 동시에 burn rate 조건을 확인하면 일시적 스파이크에 의한 오탐을 줄일 수 있습니다. 결과적으로 대응 속도와 신뢰도를 함께 확보할 수 있습니다.', ARRAY['burn-rate', 'slo', 'multi-window'], '다중 윈도우는 빠른 감지와 안정적 판단 사이의 트레이드오프를 해결한다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'otel-semantic-conventions', 4, 50, 100, 'OpenTelemetry 시맨틱 규칙을 조직 차원에서 강제해야 하는 이유와, 규칙 불일치가 분석에 주는 영향을 설명하세요.', '시맨틱 규칙을 통일하면 서비스와 언어가 달라도 동일 속성명으로 교차 분석이 가능합니다. 규칙이 불일치하면 같은 개념이 다른 키로 저장되어 대시보드와 알림 로직이 분열됩니다. 조직 차원의 검증 파이프라인과 라이브러리 가이드가 필수입니다.', ARRAY['opentelemetry', 'semantic-conventions', 'governance'], '시맨틱 일관성은 대규모 조직의 관측성 데이터 결합 가능성을 좌우한다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'loki-cardinality-control', 4, 50, 100, 'Loki에서 라벨 카디널리티 폭증이 발생하는 원인과 완화 전략을 설명하세요.', '요청 id나 사용자 id처럼 값 종류가 무한한 필드를 라벨로 쓰면 스트림 수가 폭증합니다. 이는 인덱스 메모리와 쿼리 비용을 급격히 증가시켜 성능 저하를 유발합니다. 저카디널리티 라벨만 유지하고 고카디널리티 값은 로그 본문으로 남긴 뒤 LogQL 파싱으로 조회하는 전략이 효과적입니다.', ARRAY['loki', 'cardinality', 'labels'], '카디널리티 제어는 Loki 운영 안정성의 핵심이다.', '05-monitoring-observability.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('monitoring', 'integrated-observability-architecture', 4, 50, 100, '대규모 마이크로서비스에서 관측성 플랫폼을 설계할 때 APM, 로그, 메트릭, 트레이스를 하나의 탐색 흐름으로 묶는 방법을 설명하세요.', '초기 탐지는 메트릭 기반 SLO 대시보드와 알림으로 수행하고, drill down은 Trace와 APM 트랜잭션 뷰로 연결합니다. 각 Span과 로그에 공통 trace id와 서비스 메타데이터를 주입해 클릭 한 번으로 상호 이동이 가능해야 합니다. 이 탐색 흐름이 갖춰지면 평균 복구 시간이 줄고 온콜 의사결정 일관성이 높아집니다.', ARRAY['observability', 'apm', 'correlation'], '공통 식별자 기반 탐색 흐름은 MTTR 단축에 직접 기여한다.', '05-monitoring-observability.md');

-- Security Questions (25 questions)
-- Generated by Codex/GPT based on docs/06-security.md

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'auth', 1, 1, 25, 'JWT를 서버 세션 없이 검증할 수 있는 이유와 필수 검증 클레임 두 가지를 말하세요.', 'JWT는 토큰 내용과 서명이 함께 전달되므로 서버가 키로 무결성을 직접 검증할 수 있다. exp를 확인해 만료 토큰을 차단하고, iss 또는 aud를 확인해 신뢰된 발급자와 대상 서비스인지 검증해야 한다.', ARRAY['JWT', 'exp', 'aud'], 'JWT는 상태 비저장 인증에 적합하지만 클레임 검증 누락 시 토큰 오용 위험이 커진다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'auth', 1, 1, 25, 'OAuth 2.0에서 Authorization Server와 Resource Server의 역할 차이는 무엇인가요?', 'Authorization Server는 사용자 인증과 동의 과정을 처리하고 액세스 토큰을 발급한다. Resource Server는 토큰의 유효성과 권한 범위를 검증한 뒤 API 접근을 허용하거나 거부한다.', ARRAY['OAuth2', 'Authorization Server', 'Resource Server'], '토큰 발급과 리소스 제공 주체를 분리하면 보안 경계를 명확히 할 수 있다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'owasp', 1, 1, 25, 'SQL Injection을 가장 효과적으로 막는 코딩 방법은 무엇이며 이유는 무엇인가요?', 'Prepared Statement를 사용해 쿼리 구조와 사용자 입력을 분리하는 것이 핵심이다. 또한 DB 계정에 최소 권한을 적용하면 취약점이 발생해도 피해 범위를 줄일 수 있다.', ARRAY['SQL Injection', 'Prepared Statement', 'Least Privilege'], '입력값을 문자열로 이어 붙이는 방식이 SQL Injection의 주요 원인이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'crypto', 1, 1, 25, 'AES와 RSA의 차이를 설명하고 실제 서비스에서 함께 사용하는 이유를 말하세요.', 'AES는 같은 키로 암복호화하는 대칭키 방식이라 빠르고 대용량 데이터 처리에 유리하다. RSA는 공개키 기반 비대칭 방식이라 키 교환과 서명에 적합하며, 보통 RSA 또는 ECDHE로 세션 키를 합의한 뒤 데이터는 AES로 암호화한다.', ARRAY['AES', 'RSA', 'Hybrid Encryption'], '실무에서는 성능과 키 분배 문제를 동시에 해결하기 위해 하이브리드 구성을 사용한다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'secrets', 1, 1, 25, '시크릿을 환경변수로 관리할 때 장점과 대표적인 주의사항은 무엇인가요?', '환경변수는 코드와 시크릿을 분리해 배포 파이프라인에서 교체하기 쉽다는 장점이 있다. 하지만 로그 출력, 프로세스 덤프, 잘못된 권한 설정으로 유출될 수 있어 접근 통제와 마스킹 정책이 필요하다.', ARRAY['Environment Variable', 'Secret Management', 'Access Control'], '환경변수는 편리하지만 보안 통제가 없으면 평문 저장과 동일한 위험을 가진다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'network', 1, 1, 25, 'WAF는 어떤 공격에 특히 효과적이며 왜 단독으로는 충분하지 않은가요?', 'WAF는 SQL Injection이나 XSS 같은 웹 계층 공격 패턴을 탐지하고 차단하는 데 효과적이다. 그러나 비즈니스 로직 취약점이나 내부 권한 오남용까지 막을 수는 없어서 안전한 코드와 인증 통제가 함께 필요하다.', ARRAY['WAF', 'SQL Injection', 'XSS'], 'WAF는 중요한 방어선이지만 애플리케이션 보안의 대체재는 아니다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'auth', 2, 10, 50, 'PKCE에서 code_verifier와 code_challenge를 쓰는 주된 목적은 무엇인가요?', 'PKCE는 인가 코드가 탈취되더라도 원래 클라이언트만 토큰 교환을 완료하도록 만든다. 토큰 요청 시 code_verifier를 검증해 인가 코드 가로채기 공격을 줄일 수 있다.', ARRAY['PKCE', 'code_verifier', 'OAuth2'], '모바일 앱과 SPA처럼 클라이언트 시크릿을 안전하게 보관하기 어려운 환경에서 PKCE가 필수다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'auth', 2, 10, 50, 'SMS 기반 MFA가 완전하지 않은 이유와 더 강한 대안은 무엇인가요?', 'SMS MFA는 SIM 스와핑과 메시지 탈취 공격에 노출될 수 있다. FIDO2 기반 보안키나 패스키 같은 피싱 저항형 인증 수단이 더 강한 대안이다.', ARRAY['MFA', 'SIM Swapping', 'FIDO2'], 'MFA 자체보다 인증 요소의 품질이 실제 보안 수준을 결정한다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'owasp', 2, 10, 50, '저장형 XSS와 반사형 XSS의 차이와 공통 방어 전략을 설명하세요.', '저장형 XSS는 악성 스크립트가 서버에 저장되어 다수 사용자에게 반복 전파되고, 반사형 XSS는 요청값이 즉시 응답에 반영될 때 발생한다. 공통 방어는 출력 인코딩, 입력 검증, CSP 적용이며 템플릿 자동 이스케이프를 기본값으로 두어야 한다.', ARRAY['XSS', 'Output Encoding', 'CSP'], 'XSS는 발생 위치가 달라도 브라우저에서 스크립트가 실행되는 결과는 동일하다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'owasp', 2, 10, 50, 'CSRF 공격을 막기 위해 쿠키 기반 세션에서 반드시 적용할 두 가지 방어 기법은 무엇인가요?', '서버가 발급한 CSRF 토큰을 요청마다 검증하고, 세션 쿠키에 SameSite 속성을 설정해야 한다. 또한 상태 변경 API는 GET이 아닌 POST나 PUT으로 제한하고 Origin 또는 Referer 검증을 보조적으로 사용한다.', ARRAY['CSRF', 'SameSite', 'CSRF Token'], '브라우저가 쿠키를 자동 전송한다는 특성이 CSRF의 근본 원인이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'crypto', 2, 10, 50, '비밀번호 저장에 일반 해시 대신 bcrypt를 권장하는 이유는 무엇인가요?', 'bcrypt는 계산 비용을 조절할 수 있어 오프라인 대입 공격의 속도를 의도적으로 늦출 수 있다. 또한 솔트를 자동으로 포함해 동일한 비밀번호라도 서로 다른 해시가 생성되도록 한다.', ARRAY['bcrypt', 'Password Hashing', 'Salt'], '비밀번호 저장은 빠른 해시보다 느리고 튜닝 가능한 KDF가 안전하다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'crypto', 2, 10, 50, 'TLS 1.3이 이전 버전 대비 보안을 강화한 핵심 요소 두 가지를 말하세요.', 'TLS 1.3은 취약한 암호 스위트와 레거시 핸드셰이크를 제거해 프로토콜 복잡도를 줄였다. 또한 기본적으로 전방향 보안 성질을 갖는 키 교환을 사용해 장기 키 유출 시 과거 세션 보호를 강화한다.', ARRAY['TLS 1.3', 'Cipher Suite', 'Forward Secrecy'], '불필요한 옵션을 줄이고 안전한 기본값을 강제한 것이 TLS 1.3의 핵심이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'secrets', 2, 10, 50, 'Vault의 동적 시크릿이 정적 DB 비밀번호보다 안전한 이유는 무엇인가요?', '동적 시크릿은 짧은 TTL을 가진 임시 자격증명을 발급하므로 유출돼도 사용 가능한 시간이 제한된다. 필요 시 즉시 폐기할 수 있고 사용자별 감사 로그를 남기기 쉬워 추적성과 통제가 향상된다.', ARRAY['Vault', 'Dynamic Secret', 'TTL'], '짧은 수명과 자동 회전은 시크릿 유출 리스크를 크게 낮춘다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'network', 2, 10, 50, 'DDoS 방어를 단일 장비가 아닌 다계층으로 설계해야 하는 이유를 설명하세요.', '대규모 DDoS는 네트워크, 전송, 애플리케이션 계층을 동시에 압박하므로 한 지점 방어만으로는 우회되기 쉽다. CDN과 Anycast, 속도 제한, 오토스케일링, 업스트림 스크러빙을 조합해 단계별로 트래픽을 흡수해야 한다.', ARRAY['DDoS', 'Rate Limiting', 'CDN'], '공격 유형이 다양해질수록 계층형 방어와 용량 계획이 중요해진다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'auth', 3, 30, 75, 'Passkey가 피싱에 강한 이유를 WebAuthn 동작 관점에서 설명하세요.', '패스키는 사이트 도메인에 바인딩된 공개키 인증을 사용하므로 가짜 사이트에서는 올바른 서명이 만들어지지 않는다. 개인키는 단말 보안 영역에 남아 서버로 전송되지 않아 비밀번호 재사용이나 탈취 위험도 줄어든다.', ARRAY['Passkey', 'WebAuthn', 'Phishing Resistant'], '인증 정보를 공유 비밀이 아닌 공개키 구조로 바꾸는 것이 패스키의 핵심 이점이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'owasp', 3, 30, 75, 'IDOR 취약점에서 리소스 ID를 UUID로 바꾸는 것만으로 충분하지 않은 이유는 무엇인가요?', 'UUID는 추측 난도를 높일 뿐 접근 권한 검사를 대체하지 못한다. 서버는 요청한 사용자가 해당 객체에 접근할 권한이 있는지 객체 단위로 매번 검증해야 한다.', ARRAY['IDOR', 'Authorization', 'Object Level Access Control'], '식별자 난독화는 보조 수단이며 본질적 해결책은 인가 검증이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'owasp', 3, 30, 75, 'SSRF로 클라우드 메타데이터 자격증명이 탈취되는 경로와 방어 방법을 설명하세요.', '공격자는 서버가 임의 URL에 요청하도록 유도해 169.254.169.254 같은 메타데이터 엔드포인트에 접근시킬 수 있다. 아웃바운드 허용 목록, 내부 주소 차단, 메타데이터 서비스 보호 설정을 적용하고 가능하면 IMDSv2 같은 토큰 기반 접근을 강제해야 한다.', ARRAY['SSRF', 'Metadata Service', 'IMDSv2'], '서버의 네트워크 신뢰를 악용하는 공격이므로 네트워크 정책과 애플리케이션 검증을 함께 적용해야 한다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'secrets', 3, 30, 75, 'KMS를 이용한 Envelope Encryption의 동작 순서를 간단히 설명하세요.', '애플리케이션은 데이터 키를 생성해 실제 데이터를 암호화하고, 데이터 키 자체는 KMS의 마스터 키로 다시 암호화해 저장한다. 복호화 시에는 암호화된 데이터 키를 KMS로 복호화한 뒤 원문 데이터를 복호화하므로 마스터 키를 직접 노출하지 않는다.', ARRAY['KMS', 'Envelope Encryption', 'Data Key'], '대량 데이터 암호화 성능과 키 보호를 동시에 달성하는 패턴이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'network', 3, 30, 75, 'Zero Trust 네트워크에서 mTLS가 수행하는 역할을 설명하세요.', 'mTLS는 서버뿐 아니라 클라이언트도 인증서로 상호 인증해 통신 주체의 신원을 강하게 보장한다. Zero Trust에서는 네트워크 위치를 신뢰하지 않으므로 요청마다 신원과 정책을 확인하는 기본 수단으로 mTLS가 활용된다.', ARRAY['Zero Trust', 'mTLS', 'Identity'], '내부망이라는 이유만으로 신뢰하지 않는 모델에서는 강한 기계 간 인증이 필수다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'container', 3, 30, 75, 'CI 파이프라인에서 Trivy 이미지 스캔 결과를 릴리스 게이트로 사용할 때 핵심 정책은 무엇인가요?', '빌드 단계에서 취약점 심각도 기준을 정의하고 HIGH 또는 CRITICAL 발견 시 배포를 차단해야 한다. 예외가 필요한 경우 만료일이 있는 승인 절차와 재검증 조건을 함께 기록해 기술 부채가 누적되지 않게 관리한다.', ARRAY['Trivy', 'Image Scan', 'CI/CD Security'], '스캔 도구 도입만으로는 부족하며 차단 기준과 예외 통제가 함께 있어야 효과가 난다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'compliance', 3, 30, 75, 'GDPR 관점에서 개인정보 침해 사고를 인지했을 때 지켜야 할 시간 기준과 초기 조치는 무엇인가요?', '개인정보 침해를 인지하면 원칙적으로 72시간 이내에 감독기관 신고 여부를 판단하고 필요한 통지를 진행해야 한다. 동시에 사고 범위 파악, 증거 보존, 임시 차단 조치를 수행해 추가 피해를 줄여야 한다.', ARRAY['GDPR', 'Breach Notification', 'Incident Response'], '법적 기한 준수와 기술적 대응을 병행해야 컴플라이언스 리스크를 줄일 수 있다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'auth', 4, 50, 100, 'SPA에서 OAuth 2.0을 구현할 때 Implicit Flow 대신 Authorization Code with PKCE와 Refresh Token Rotation을 권장하는 이유는 무엇인가요?', 'Authorization Code with PKCE는 토큰 교환 단계에서 클라이언트 정당성을 추가 검증해 코드 탈취 위험을 낮춘다. Refresh Token Rotation을 적용하면 리프레시 토큰 재사용을 탐지해 세션 탈취를 더 빠르게 차단할 수 있다.', ARRAY['OAuth2', 'PKCE', 'Refresh Token Rotation'], '현대 브라우저 환경에서는 토큰 노출과 재사용 공격을 줄이는 설계가 핵심이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'crypto', 4, 50, 100, 'PFS가 없는 키 교환을 사용할 때 서버 개인키 유출이 초래하는 위험을 설명하세요.', 'PFS가 없으면 공격자가 과거에 수집한 암호화 트래픽을 서버 개인키로 나중에 복호화할 수 있다. ECDHE 기반 PFS를 사용하면 세션별 임시 키가 사용되어 장기 키가 유출돼도 과거 세션 기밀성이 유지된다.', ARRAY['PFS', 'ECDHE', 'TLS'], '장기 키 유출을 전제로 한 피해 확산을 줄이는 것이 PFS의 본질적 목적이다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'container', 4, 50, 100, '컨테이너 런타임에서 seccomp와 SBOM을 함께 운영할 때 SOC2 관점에서 어떤 증적 가치를 만들 수 있나요?', 'seccomp는 허용된 시스템 콜만 실행하게 해 런타임 공격면을 줄이고 통제 정책의 존재를 증명한다. SBOM은 배포 아티팩트에 포함된 구성요소와 버전을 명확히 보여 주어 취약점 영향 분석과 패치 추적의 근거가 된다. 두 통제를 연결하면 예방 통제와 변경 추적 통제를 함께 입증해 SOC2 감사 대응이 쉬워진다.', ARRAY['seccomp', 'SBOM', 'SOC2'], '감사에서는 통제의 설계뿐 아니라 운영 증적이 중요하므로 자동 수집 체계가 필요하다.', '06-security.md');

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES ('security', 'compliance', 4, 50, 100, '랜섬웨어 발생 시 조직의 IR 프로세스를 준비 단계부터 사후 개선까지 순서대로 설명하세요.', '준비 단계에서 역할과 연락 체계를 정의하고, 탐지 후에는 즉시 격리와 확산 차단을 수행한다. 이후 근절과 복구를 통해 정상 서비스를 단계적으로 복원하고 무결성을 검증한다. 마지막으로 포렌식 결과와 교훈을 바탕으로 정책, 통제, 훈련을 업데이트해 재발 가능성을 낮춘다.', ARRAY['Incident Response', 'Containment', 'Postmortem'], '사고 대응은 기술 복구뿐 아니라 커뮤니케이션과 재발 방지까지 포함한 전 주기 활동이다.', '06-security.md');
