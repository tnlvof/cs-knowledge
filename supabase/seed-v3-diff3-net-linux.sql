-- CS Knowledge Quiz RPG - Senior Level (Difficulty 3) Network & Linux Questions
-- Total: 50 questions (network: 25, linux: 25)
-- Level Range: level_min=30, level_max=75
-- Created: 2026-02-14

-- =============================================
-- NETWORK 문제 (25문제) - 시니어급
-- =============================================

-- 1. DNS 심화
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'dns', 3, 30, 75, '대규모 서비스에서 DNS Failover를 구현할 때 Health Check 기반 DNS와 단순 TTL 기반의 차이점 및 각각의 한계를 설명해주세요.', 'Health Check 기반(Route53, Cloudflare): 주기적으로 엔드포인트 상태를 확인하여 장애 감지 시 자동으로 DNS 레코드에서 제외합니다. 장점은 자동화된 장애 대응이지만, 체크 간격(보통 10-30초)과 DNS 캐시 TTL로 인해 실제 전환까지 지연이 발생합니다. 단순 TTL 기반은 수동 변경이 필요하고 TTL 만료까지 구 IP로 트래픽이 갑니다. 한계점: DNS 캐시는 클라이언트/리졸버마다 다르게 동작하며, 일부 클라이언트는 TTL을 무시합니다. 완벽한 실시간 전환을 위해서는 Anycast나 L4 로드밸런서를 조합해야 합니다.', ARRAY['DNS Failover', 'Health Check', 'TTL', 'Route53', 'Anycast'], 'DNS 기반 페일오버는 간단하지만 완벽하지 않습니다. 미션 크리티컬 서비스는 DNS + L4 LB + 애플리케이션 레벨 재시도를 조합합니다.', 'docs/01-network.md');

-- 2. TCP 성능
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tcp', 3, 30, 75, '고지연 네트워크(위성, 대륙간 연결)에서 TCP 성능이 저하되는 근본 원인과 이를 개선하기 위한 프로토콜/커널 레벨 접근법을 설명해주세요.', 'TCP의 혼잡 제어(AIMD)는 패킷 손실을 혼잡 신호로 해석하여 윈도우를 줄입니다. 고지연 환경에서는 BDP(Bandwidth-Delay Product)가 커서 기존 알고리즘(CUBIC 등)이 대역폭을 충분히 활용하지 못합니다. 개선책: 1) BBR 혼잡 제어 - 손실 대신 RTT와 대역폭을 직접 측정하여 최적점 탐색 2) TCP 버퍼 튜닝 - rmem_max, wmem_max를 BDP 이상으로 설정 3) TCP Fast Open으로 핸드셰이크 중 데이터 전송 4) TLS 1.3의 0-RTT 활용 5) 애플리케이션에서 멀티플렉싱(HTTP/2, QUIC) 사용으로 연결 재사용.', ARRAY['BDP', 'BBR', 'CUBIC', 'TCP Fast Open', '고지연네트워크', '혼잡제어'], 'BBR은 Google이 YouTube 트래픽에서 처리량을 4% 향상시킨 혼잡 제어 알고리즘입니다.', 'docs/01-network.md');

-- 3. TLS 인증서 자동화
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tls', 3, 30, 75, 'Kubernetes 환경에서 cert-manager를 사용한 인증서 자동화 파이프라인 구축 시 고려해야 할 아키텍처적 요소들을 설명해주세요.', '주요 고려사항: 1) Issuer/ClusterIssuer 선택 - 네임스페이스별 vs 클러스터 전역 2) ACME Challenge 방식 - HTTP-01(인그레스 필요), DNS-01(와일드카드 지원, DNS 프로바이더 연동) 3) 인증서 갱신 주기와 renewBefore 설정 - Let''s Encrypt 90일 인증서의 경우 30일 전 갱신 시작 4) 시크릿 동기화 - 멀티 네임스페이스에서 인증서 공유 방법 5) Rate Limit 관리 - 스테이징 환경에서 테스트 후 프로덕션 적용 6) 모니터링 - 인증서 만료 알림(Prometheus exporter). 장애 시나리오: DNS 전파 지연, API Rate Limit 초과, 권한 문제 등에 대한 대응책 필요.', ARRAY['cert-manager', 'ACME', 'Let''s Encrypt', 'Kubernetes', 'DNS-01', 'HTTP-01'], 'cert-manager는 Kubernetes의 사실상 표준 인증서 관리 도구로, Ingress와 연동하여 자동 발급/갱신합니다.', 'docs/01-network.md');

-- 4. HTTP 캐싱 전략
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'http', 3, 30, 75, 'API 응답에 대한 HTTP 캐싱 전략을 설계할 때 Cache-Control, ETag, Vary 헤더의 조합 사용법과 각각의 사용 시나리오를 설명해주세요.', 'Cache-Control: max-age는 캐시 유효 시간, public/private는 공유 캐시 허용 여부, no-cache는 매번 재검증, stale-while-revalidate는 만료 후에도 즉시 응답하고 백그라운드 갱신. ETag: 컨텐츠 해시로 If-None-Match 요청 시 변경 여부 확인, 304 Not Modified로 대역폭 절약. Vary: 같은 URL이라도 다른 캐시를 유지할 조건(Accept-Encoding, Accept-Language, Authorization 등). 시나리오별 적용: 정적 자산은 max-age=31536000 + 파일명 해시, API 응답은 private, max-age=0, must-revalidate + ETag, 사용자별 데이터는 Vary: Authorization으로 캐시 분리.', ARRAY['Cache-Control', 'ETag', 'Vary', 'stale-while-revalidate', 'HTTP캐싱'], 'Vary 헤더 설정 실수는 캐시 히트율 저하나 잘못된 응답 반환의 원인이 됩니다.', 'docs/01-network.md');

-- 5. WebSocket 보안
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'websocket', 3, 30, 75, 'WebSocket 연결에 대한 인증/인가 구현 시 HTTP 쿠키 기반과 토큰 기반 방식의 장단점 및 보안 고려사항을 비교해주세요.', '쿠키 기반: 장점은 자동 전송으로 구현 간단, 기존 세션 인프라 활용 가능. 단점은 CORS 제약, 모바일 앱에서 사용 어려움, CSRF 취약. 토큰 기반(JWT/커스텀): 장점은 stateless, 크로스 도메인 용이, 모바일 호환. 단점은 토큰 만료/갱신 처리 필요, 초기 연결 시 토큰 전달 방법(쿼리스트링은 로그 노출 위험, 첫 메시지로 전달 권장). 공통 보안 고려: 1) wss:// 필수 사용 2) Origin 헤더 검증으로 CSWSH 방지 3) 연결 후에도 메시지별 권한 검증 4) Rate limiting 5) 연결 수 제한. 토큰 갱신: 연결 중 토큰 만료 시 재연결하거나 갱신 토큰 메시지 프로토콜 설계.', ARRAY['WebSocket 인증', 'JWT', 'CSWSH', 'Origin검증', 'wss'], 'WebSocket은 핸드셰이크 후 지속 연결이므로 초기 인증 외에도 세션 유지와 권한 변경에 대한 고려가 필요합니다.', 'docs/01-network.md');

-- 6. 로드밸런서 알고리즘
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'loadbalancer', 3, 30, 75, '마이크로서비스 환경에서 서비스 간 지연 시간 차이가 큰 경우, 적절한 로드밸런싱 알고리즘 선택과 그 이유를 설명해주세요.', '지연 시간 차이가 큰 환경에서는 Least Connections 또는 가중치 기반 알고리즘이 적합합니다. Round Robin은 응답 시간을 고려하지 않아 느린 서버에 요청이 누적됩니다. Least Connections: 현재 연결 수가 적은 서버로 분배하여 느린 서버의 연결이 오래 유지되면 자연스럽게 요청이 줄어듭니다. 더 고급 방식: Weighted Response Time - 응답 시간을 측정하여 가중치로 반영, EWMA(Exponentially Weighted Moving Average) 활용. Peak EWMA: 피크 지연 시간 기반으로 과부하 서버 회피. 서비스 메시(Istio, Linkerd)는 P99 지연 기반 outlier detection으로 느린 인스턴스를 자동 제외합니다.', ARRAY['Least Connections', 'Round Robin', 'Weighted Response Time', 'EWMA', '로드밸런싱알고리즘'], '서비스 메시의 클라이언트 사이드 로드밸런싱은 실시간 지연 정보를 활용하여 더 정교한 분배가 가능합니다.', 'docs/01-network.md');

-- 7. CDN 캐시 전략
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'cdn', 3, 30, 75, 'API 응답을 CDN에서 캐싱할 때 사용자별 개인화 데이터와 공통 데이터를 효율적으로 분리하여 캐시 히트율을 높이는 전략을 설명해주세요.', '핵심 전략은 응답 분리입니다: 1) Edge Side Includes(ESI) - 페이지를 조각으로 나눠 공통 부분은 캐시, 개인화 부분은 별도 요청 2) API 분리 - /api/products(캐시 가능)와 /api/user/recommendations(캐시 불가)로 엔드포인트 분리 3) 클라이언트 조합 - 공통 데이터는 CDN에서, 개인화는 직접 오리진에서 가져와 클라이언트에서 조합. Vary 헤더 활용: Vary: Accept-Encoding은 OK, Vary: Cookie나 Authorization은 캐시 히트율 급락. 캐시 키 최적화: 불필요한 쿼리 파라미터 제거, 순서 정규화. Stale-while-revalidate로 만료 직후에도 기존 캐시 반환하며 백그라운드 갱신.', ARRAY['ESI', 'Vary헤더', '캐시키최적화', 'API분리', 'CDN캐싱전략'], 'Vary: Cookie 사용 시 쿠키 값마다 별도 캐시가 생성되어 사실상 캐싱 무효화와 같습니다.', 'docs/01-network.md');

-- 8. VPN 터널링
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'vpn', 3, 30, 75, 'WireGuard와 IPSec VPN의 아키텍처 차이점 및 대규모 원격 접속 환경에서의 선택 기준을 설명해주세요.', 'IPSec: IKE(Internet Key Exchange)로 키 교환, ESP/AH로 암호화/인증, 복잡한 상태 머신, 다양한 암호화 스위트 지원, NAT-Traversal 추가 설정 필요. WireGuard: 단순한 설계(약 4000줄 코드 vs IPSec 수십만 줄), Noise 프로토콜 기반 키 교환, ChaCha20-Poly1305 고정, UDP만 사용, 커널 통합으로 고성능. 선택 기준: 대규모 원격 접속은 WireGuard가 설정 간소화, 연결 속도, 모바일 로밍에 유리. 기업 환경에서 레거시 호환성, 감사 요구사항, 기존 인프라 통합이 필요하면 IPSec. 하이브리드 클라우드 Site-to-Site는 클라우드 제공사 VPN Gateway(IPSec 기반)가 관리형으로 편리.', ARRAY['WireGuard', 'IPSec', 'IKE', 'Noise Protocol', 'VPN비교'], 'WireGuard는 커널 5.6+에 기본 포함되어 별도 설치 없이 사용 가능합니다.', 'docs/01-network.md');

-- 9. 방화벽 규칙 설계
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'firewall', 3, 30, 75, '클라우드 환경에서 마이크로서비스 간 통신을 위한 Security Group 설계 시 IP 기반 대신 Security Group 참조 방식의 장점과 구현 패턴을 설명해주세요.', 'SG 참조 방식 장점: 1) IP 변경에 영향 받지 않음 - Auto Scaling, 재배포 시에도 규칙 유지 2) 동적 멤버십 - 인스턴스가 SG에 추가되면 자동으로 통신 허용 3) 가독성 - "web-sg에서 app-sg 허용"이 IP 나열보다 의도가 명확 4) 관리 용이 - 규칙 수 감소. 구현 패턴: 계층별 SG 설계 - ALB-SG → Web-SG → App-SG → DB-SG로 체이닝. 서비스별 SG - 각 마이크로서비스가 고유 SG를 가지고 필요한 서비스 SG만 허용. 공통 SG - Bastion, 모니터링 에이전트 등 공통 접근용. 주의점: SG 개수 제한(VPC당 2500개), 인스턴스당 SG 5개 제한 확인.', ARRAY['Security Group', 'SG참조', '마이크로세그멘테이션', 'AWS 방화벽', '네트워크격리'], 'SG 참조는 같은 VPC 내에서만 동작합니다. 크로스 VPC는 VPC Peering + CIDR 방식 필요.', 'docs/01-network.md');

-- 10. NAT 대규모 환경
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'nat', 3, 30, 75, '대규모 서비스에서 NAT Gateway의 포트 고갈 문제가 발생했습니다. 원인 분석 방법과 해결 전략을 설명해주세요.', '원인: NAT Gateway는 소스 IP당 약 55,000개 포트를 동시 사용 가능합니다. 동일 목적지에 대한 연결이 많으면 5-tuple(src IP, src port, dst IP, dst port, protocol) 조합이 부족해집니다. 분석: CloudWatch의 ErrorPortAllocation 메트릭 확인, VPC Flow Logs로 연결 패턴 분석. 해결 전략: 1) 다중 NAT Gateway - 서브넷별로 NAT GW를 분리하여 소스 IP 분산 2) 목적지 분산 - 같은 서비스라도 여러 IP/엔드포인트 사용 3) 연결 재사용 - Keep-Alive, Connection Pooling으로 연결 생성 최소화 4) 프라이빗 엔드포인트 - AWS 서비스(S3, DynamoDB)는 VPC Endpoint 사용으로 NAT 우회 5) Egress Only IGW - IPv6 사용 시 NAT 불필요.', ARRAY['NAT Gateway', '포트고갈', 'ErrorPortAllocation', 'VPC Endpoint', '연결재사용'], 'S3 대량 업로드/다운로드는 흔한 포트 고갈 원인으로, Gateway Endpoint 사용을 권장합니다.', 'docs/01-network.md');

-- 11. BGP 보안
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'bgp', 3, 30, 75, 'BGP Hijacking 공격의 원리와 이를 탐지/방어하기 위한 RPKI 구현 방법을 설명해주세요.', 'BGP Hijacking 원리: 공격자가 자신의 AS에서 타인의 IP 프리픽스를 announce하면, 일부 라우터가 더 구체적인 프리픽스나 짧은 AS 경로를 선호하여 트래픽을 공격자로 라우팅합니다. RPKI(Resource Public Key Infrastructure): IP 주소 블록과 AS의 연결을 암호학적으로 증명합니다. ROA(Route Origin Authorization) 객체로 "이 프리픽스는 이 AS만 announce 가능"을 선언. 구현: 1) RIR(Regional Internet Registry)에서 ROA 생성 2) RPKI Validator 서버 운영 또는 관리형 서비스 사용 3) 라우터에서 ROV(Route Origin Validation) 활성화 4) Invalid 경로 거부 또는 우선순위 낮춤. 한계: RPKI 채택률이 아직 50% 미만, 경로 누출은 방어 불가(BGPsec 필요).', ARRAY['BGP Hijacking', 'RPKI', 'ROA', 'ROV', 'AS경로'], 'RPKI 채택은 2024년 기준 Amazon, Google 등 주요 사업자가 완료했으나 전체 인터넷은 부분 적용 상태입니다.', 'docs/01-network.md');

-- 12. QUIC 프로토콜
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'http', 3, 30, 75, 'QUIC 프로토콜의 Connection Migration 기능이 모바일 환경에서 어떻게 사용자 경험을 개선하는지 기술적으로 설명해주세요.', 'TCP는 4-tuple(src IP, src port, dst IP, dst port)로 연결을 식별하여 IP 변경(WiFi↔LTE 전환) 시 연결이 끊어집니다. QUIC의 Connection Migration: 연결을 Connection ID(랜덤 토큰)로 식별하여 IP 변경에도 연결 유지. 동작 과정: 1) 클라이언트 IP 변경 감지 2) 새 경로로 PATH_CHALLENGE 프레임 전송 3) 서버가 PATH_RESPONSE로 경로 검증 4) 새 경로에서 기존 연결 ID로 통신 계속. 사용자 경험 개선: 지하철 이동 중 네트워크 전환에도 스트리밍/다운로드 중단 없음, 앱 재연결 대기 시간 제거, 데이터 재전송 최소화. 보안 고려: 경로 검증으로 IP 스푸핑 기반 연결 탈취 방지, 각 경로별 암호화 키 분리.', ARRAY['QUIC', 'Connection Migration', 'Connection ID', 'PATH_CHALLENGE', '모바일네트워크'], 'YouTube 모바일 앱에서 QUIC 사용 시 네트워크 전환으로 인한 재버퍼링이 크게 감소했습니다.', 'docs/01-network.md');

-- 13. 프록시 체인
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'proxy', 3, 30, 75, '엔터프라이즈 환경에서 Forward Proxy, Reverse Proxy, Transparent Proxy의 차이점과 각각의 배치 시나리오를 설명해주세요.', 'Forward Proxy: 클라이언트를 대신하여 외부 서버에 요청, 클라이언트가 프록시를 명시적으로 설정. 용도: 기업 내부에서 인터넷 접근 통제, 캐싱, 로깅, 익명성. Reverse Proxy: 서버를 대신하여 클라이언트 요청 수신, 클라이언트는 프록시 존재를 모름. 용도: 로드밸런싱, SSL 종료, 캐싱, WAF, 백엔드 보호. Transparent Proxy: 클라이언트 설정 없이 네트워크 레벨에서 트래픽 가로채기, 라우터/방화벽에서 리다이렉션. 용도: ISP의 캐싱, 기업의 컨텐츠 필터링, HTTPS 인터셉션(인증서 문제 발생). 배치: Forward는 클라이언트 측(기업 게이트웨이), Reverse는 서버 측(DMZ), Transparent는 네트워크 인프라(라우터/스위치).', ARRAY['Forward Proxy', 'Reverse Proxy', 'Transparent Proxy', 'DMZ', '프록시배치'], 'HTTPS Transparent Proxy는 TLS를 가로채므로 클라이언트에 프록시 CA 인증서 설치가 필요합니다.', 'docs/01-network.md');

-- 14. 네트워크 QoS
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tcp', 3, 30, 75, '실시간 화상회의와 파일 전송이 같은 네트워크를 사용할 때 QoS를 적용하여 화상회의 품질을 보장하는 방법을 설명해주세요.', 'QoS 구현 계층: 1) L2(DSCP 마킹): 패킷에 우선순위 태그 부여 - 화상회의는 EF(Expedited Forwarding, DSCP 46), 일반 데이터는 BE(Best Effort) 2) L3(라우터): 대역폭 보장(화상회의에 최소 2Mbps 예약), 큐잉(Priority Queuing으로 EF 먼저 처리), 폴리싱/셰이핑(파일 전송 최대 대역폭 제한) 3) 애플리케이션: WebRTC의 경우 RTCP로 네트워크 상태 피드백, 비트레이트 적응. 구현 위치: 엔드포인트(화상회의 앱이 DSCP 설정), 스위치(DSCP 기반 큐 분류), WAN 라우터(정책 적용). 클라우드 환경: AWS VPC는 QoS 미지원, Direct Connect는 DSCP 유지. SD-WAN은 애플리케이션 인식 QoS 제공.', ARRAY['QoS', 'DSCP', 'Traffic Shaping', 'Priority Queuing', 'WebRTC'], '클라우드/인터넷 구간에서는 DSCP가 재설정되거나 무시될 수 있어 종단간 QoS 보장이 어렵습니다.', 'docs/01-network.md');

-- 15. ARP 보안
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'arp', 3, 30, 75, 'ARP Spoofing 공격을 탐지하고 방어하기 위한 네트워크 레벨 및 호스트 레벨 대응 방안을 설명해주세요.', 'ARP Spoofing 원리: 공격자가 위조된 ARP Reply를 보내 자신의 MAC을 게이트웨이 IP에 매핑시켜 트래픽을 가로챕니다. 네트워크 레벨 방어: 1) Dynamic ARP Inspection(DAI) - 스위치가 DHCP Snooping 바인딩 테이블과 ARP 패킷 비교 2) Port Security - MAC 주소 수 제한 3) 802.1X 인증 - 네트워크 접근 통제 4) VLAN 분리 - 브로드캐스트 도메인 최소화. 호스트 레벨 방어: 1) Static ARP 엔트리 - 게이트웨이 MAC 고정(arp -s) 2) ARP 모니터링 도구(arpwatch, XArp) - 변경 감지 알림 3) VPN/IPSec - 로컬 네트워크 신뢰하지 않고 암호화. 탐지: 같은 IP에 대해 다른 MAC이 나타나면 의심, Gratuitous ARP 다량 발생 모니터링.', ARRAY['ARP Spoofing', 'DAI', 'DHCP Snooping', 'arpwatch', 'MITM'], 'ARP는 인증 메커니즘이 없어 태생적으로 취약하며, L2 보안은 물리적 접근 통제와 함께 고려해야 합니다.', 'docs/01-network.md');

-- 16. SSL/TLS 핸드셰이크 최적화
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tls', 3, 30, 75, 'TLS 핸드셰이크 지연을 최소화하기 위한 TLS 1.3, Session Resumption, OCSP Stapling의 동작 원리와 적용 방법을 설명해주세요.', 'TLS 1.3 개선: 핸드셰이크를 2-RTT에서 1-RTT로 단축, 0-RTT Resumption으로 이전 연결 재개 시 첫 패킷에 데이터 포함 가능(Replay Attack 주의). Session Resumption: Session ID 방식(서버 상태 저장) 또는 Session Ticket 방식(암호화된 세션 정보를 클라이언트에 저장), TLS 1.3의 PSK(Pre-Shared Key). OCSP Stapling: 서버가 OCSP 응답을 미리 CA에서 받아 인증서와 함께 전송, 클라이언트가 직접 CA에 조회하는 지연 제거. 적용: Nginx에서 ssl_protocols TLSv1.3, ssl_session_cache shared:SSL:10m, ssl_session_timeout 1d, ssl_stapling on, ssl_stapling_verify on 설정. 주의: 0-RTT는 replay 가능하므로 멱등성 없는 요청에 주의.', ARRAY['TLS 1.3', 'Session Resumption', 'OCSP Stapling', '0-RTT', 'PSK'], '0-RTT는 재시도 안전한(idempotent) GET 요청에만 사용하고, POST 등에는 Early Data 거부를 권장합니다.', 'docs/01-network.md');

-- 17. 네트워크 트러블슈팅
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tcp', 3, 30, 75, '특정 서버로의 연결에서 간헐적으로 Connection Timeout이 발생합니다. tcpdump와 ss를 활용한 체계적인 진단 방법을 설명해주세요.', '진단 단계: 1) ss -tnp로 현재 연결 상태 확인 - SYN-SENT 누적은 서버 미응답 징후 2) tcpdump -i eth0 host 대상IP and port 포트 -w capture.pcap으로 패킷 캡처 3) Wireshark에서 분석 - SYN 전송 후 SYN-ACK 없으면 서버/네트워크 문제, RST 수신 시 포트 닫힘이나 방화벽 4) 양쪽 서버에서 동시 캡처로 어느 구간에서 패킷 손실인지 파악 5) traceroute/mtr로 경로상 문제 확인. 점검 항목: 서버 Listen 큐 오버플로우(netstat -s | grep overflow), SYN Flood 방어 설정(syncookies), 방화벽 conntrack 테이블 포화, 중간 네트워크 장비(로드밸런서, NAT)의 타임아웃 설정. 클라우드: Security Group, NACL, 라우팅 테이블 순차 확인.', ARRAY['tcpdump', 'ss', 'Connection Timeout', 'SYN-SENT', '패킷캡처'], '간헐적 문제는 재현이 어려우므로 지속적인 패킷 캡처와 메트릭 수집이 중요합니다.', 'docs/01-network.md');

-- 18. 서비스 디스커버리
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'dns', 3, 30, 75, '마이크로서비스 환경에서 DNS 기반 서비스 디스커버리와 클라이언트 사이드 디스커버리(Consul, etcd)의 트레이드오프를 비교해주세요.', 'DNS 기반(Kubernetes Service, Route53 Private Zone): 장점은 표준 프로토콜로 모든 언어/프레임워크 호환, 기존 인프라 활용. 단점은 DNS 캐싱으로 실시간성 부족(TTL 지연), 헬스체크 통합 어려움, 로드밸런싱 옵션 제한(라운드로빈). 클라이언트 사이드(Consul, etcd, Eureka): 장점은 실시간 갱신, 상세 헬스체크, 메타데이터 기반 라우팅, 다양한 로드밸런싱 알고리즘. 단점은 클라이언트 라이브러리 의존성, 추가 인프라 운영. 하이브리드: 서비스 메시(Istio)가 Envoy 사이드카로 디스커버리 처리, 애플리케이션은 localhost로 요청. 선택 기준: 간단한 환경은 DNS, 고급 트래픽 관리 필요 시 전용 디스커버리, 대규모는 서비스 메시.', ARRAY['서비스디스커버리', 'Consul', 'etcd', 'Kubernetes Service', '서비스메시'], 'Kubernetes의 Headless Service는 클라이언트에 개별 Pod IP를 반환하여 클라이언트 사이드 로드밸런싱을 가능케 합니다.', 'docs/01-network.md');

-- 19. 멀티캐스트
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'udp', 3, 30, 75, '대규모 실시간 스트리밍 서비스에서 IP Multicast 대신 유니캐스트 기반 CDN을 사용하는 이유와 각 방식의 아키텍처 차이를 설명해주세요.', 'IP Multicast 한계: 1) ISP 간 멀티캐스트 라우팅(MBONE) 미지원이 대부분 2) 상태 관리 복잡(그룹 가입/탈퇴 추적) 3) 신뢰성 없음(패킷 손실 복구 어려움) 4) 방화벽/NAT 통과 문제 5) 엔터프라이즈 네트워크 내부에서만 실용적. 유니캐스트 CDN: 1) 엣지 서버가 오리진에서 한 번 수신 후 각 클라이언트에 유니캐스트 2) HTTP(HLS, DASH)로 표준 인프라 활용 3) 적응형 비트레이트로 네트워크 상황 대응 4) 되감기/일시정지 등 DVR 기능 5) CDN의 글로벌 분산으로 지연 최소화. 하이브리드: 데이터센터 내부나 기업 네트워크에서는 멀티캐스트로 대역폭 절약, 인터넷 구간은 CDN 유니캐스트. WebRTC SFU도 서버가 수신 후 각 참가자에 전달하는 유니캐스트 방식.', ARRAY['Multicast', 'Unicast', 'CDN', 'HLS', 'DASH'], '라이브 스트리밍에서 수백만 동시 시청자를 처리하는 것은 CDN 분산과 캐싱의 조합으로 가능합니다.', 'docs/01-network.md');

-- 20. HTTP/2 Server Push
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'http', 3, 30, 75, 'HTTP/2 Server Push가 실제로 성능을 저하시킬 수 있는 시나리오와 대안적인 리소스 최적화 기법을 설명해주세요.', 'Server Push 문제점: 1) 클라이언트 캐시 무시 - 이미 캐시된 리소스도 푸시하여 대역폭 낭비 2) 우선순위 문제 - 중요하지 않은 리소스가 먼저 푸시될 수 있음 3) 복잡한 구현 - 어떤 리소스를 푸시할지 결정 로직 필요 4) 브라우저 지원 중단 추세 - Chrome은 HTTP/2 Push 제거 결정. 대안: 1) preload 힌트 - <link rel="preload"> 또는 Link 헤더로 클라이언트가 조기에 요청 시작 2) 103 Early Hints - 최종 응답 전에 힌트 전송 3) 번들링 최적화 - 크리티컬 CSS 인라인, 코드 스플리팅 4) HTTP/3 우선순위 - 클라이언트가 리소스 우선순위 지정 5) 서비스 워커 - 프리캐싱으로 필요 리소스 미리 저장.', ARRAY['HTTP/2 Server Push', 'preload', '103 Early Hints', '리소스최적화', '크리티컬CSS'], 'Server Push는 이론적으로 좋았으나 실제 효과가 제한적이어서 주요 브라우저에서 제거되고 있습니다.', 'docs/01-network.md');

-- 21. 네트워크 보안 모니터링
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'firewall', 3, 30, 75, '클라우드 환경에서 VPC Flow Logs를 활용한 네트워크 이상 탐지 및 보안 분석 방법을 설명해주세요.', 'VPC Flow Logs 수집 항목: 소스/목적지 IP/포트, 프로토콜, 패킷/바이트 수, 허용/거부 상태, 시간. 분석 활용: 1) 거부된 트래픽 패턴 분석 - 포트 스캔 탐지(짧은 시간에 여러 포트 거부) 2) 비정상 아웃바운드 - 내부 서버에서 외부 C&C 서버로 연결 시도 3) 데이터 유출 탐지 - 비정상적으로 큰 아웃바운드 트래픽 4) 내부 횡적 이동 - 서버간 비정상 통신 패턴 5) 규정 준수 - 특정 포트 사용 정책 위반. 분석 도구: CloudWatch Logs Insights, Athena로 S3에 저장된 로그 쿼리, 서드파티 SIEM(Splunk, Sumo Logic). 실시간 알림: CloudWatch Metrics + Alarm으로 거부 급증 감지, Lambda로 자동 대응.', ARRAY['VPC Flow Logs', '네트워크보안', 'SIEM', '이상탐지', 'CloudWatch'], 'Flow Logs는 패킷 내용은 포함하지 않으므로 상세 분석은 별도 패킷 캡처가 필요합니다.', 'docs/01-network.md');

-- 22. gRPC 네트워크
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'http', 3, 30, 75, 'gRPC 서비스에서 로드밸런서를 통한 트래픽 분산 시 HTTP/2의 멀티플렉싱으로 인해 발생하는 문제와 해결 방안을 설명해주세요.', 'HTTP/2 멀티플렉싱 문제: 하나의 TCP 연결에서 여러 요청을 처리하므로 L4 로드밸런서가 연결 단위로만 분배하면 특정 백엔드에 요청이 집중됩니다. 해결 방안: 1) L7 로드밸런서 - gRPC 요청 단위로 분배(AWS ALB는 gRPC 지원, Envoy, Nginx) 2) 클라이언트 사이드 로드밸런싱 - grpc-go의 round_robin/pick_first 정책, 서비스 디스커버리와 연동 3) Lookaside LB - 전용 로드밸런서 서비스가 백엔드 목록 제공 4) 서비스 메시 - Envoy 사이드카가 요청 레벨 라우팅. 추가 고려: gRPC 연결은 오래 유지되므로 백엔드 추가/제거 시 연결 재분배 필요, 헬스체크는 gRPC Health Checking Protocol 사용.', ARRAY['gRPC', 'HTTP/2 멀티플렉싱', 'L7로드밸런서', '클라이언트사이드LB', 'Envoy'], 'Kubernetes에서 gRPC는 Headless Service + 클라이언트 사이드 LB나 서비스 메시 사용을 권장합니다.', 'docs/01-network.md');

-- 23. 네트워크 레이턴시 분석
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tcp', 3, 30, 75, '마이크로서비스 간 호출에서 P99 지연 시간이 비정상적으로 높은 원인을 분석하기 위한 분산 트레이싱과 네트워크 레벨 진단 방법을 설명해주세요.', '분산 트레이싱(Jaeger, Zipkin): 1) 각 서비스의 처리 시간(span) 확인으로 병목 서비스 식별 2) 서비스 간 네트워크 시간(span 사이 gap) 분석 3) 느린 호출의 공통 패턴 찾기(특정 인스턴스, 시간대). 네트워크 레벨 진단: 1) ss -i로 TCP 재전송(retransmits), RTT 확인 2) netstat -s로 TCP 에러 통계 3) conntrack 테이블 포화 여부 4) iptables 규칙 처리 지연 5) 컨테이너 네트워크(CNI) 오버헤드. 서버 레벨: 1) CPU 스로틀링(cgroup 제한) 2) GC 일시정지 3) 커넥션 풀 고갈 4) DNS 조회 지연. P99가 높은 이유: 재전송, GC, 콜드 스타트 등 간헐적 이벤트가 꼬리 지연에 영향. Histogram 분포 분석으로 bimodal 분포인지 확인.', ARRAY['분산트레이싱', 'P99지연', 'Jaeger', 'TCP재전송', '네트워크지연'], 'P99 최적화는 평균보다 어렵습니다. 간헐적 원인을 찾기 위해 충분한 샘플과 상관관계 분석이 필요합니다.', 'docs/01-network.md');

-- 24. 네트워크 암호화
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tls', 3, 30, 75, '내부 마이크로서비스 통신에서 TLS 적용 시 발생하는 성능 오버헤드를 측정하고 최소화하는 방법을 설명해주세요.', '성능 오버헤드: 1) 핸드셰이크 지연 - TLS 1.2는 2-RTT, TLS 1.3은 1-RTT 2) 암호화/복호화 CPU 사용 - 특히 RSA 키 교환 3) 메모리 사용 - 세션 상태 저장. 측정 방법: 1) 동일 요청의 HTTP vs HTTPS 응답 시간 비교 2) perf로 openssl/crypto 관련 CPU 사용 확인 3) TLS 핸드셰이크 횟수 모니터링. 최소화 전략: 1) TLS 1.3 사용 - 핸드셰이크 단축, 효율적 암호화 2) ECDHE over RSA - 키 교환 속도 향상 3) Session Resumption - 핸드셰이크 생략 4) Connection Pooling - 연결 재사용 5) Hardware Acceleration - AES-NI, TLS 오프로드 NIC. 서비스 메시: Envoy가 TLS 처리하여 앱에서 오버헤드 분리, 사이드카에서 mTLS 효율적 관리.', ARRAY['TLS오버헤드', 'AES-NI', 'Session Resumption', 'mTLS성능', '암호화최적화'], '현대 하드웨어(AES-NI)에서 TLS 암호화 오버헤드는 일반적으로 CPU 1-2% 수준입니다.', 'docs/01-network.md');

-- 25. IPv6 전환
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('network', 'tcp', 3, 30, 75, '기존 IPv4 인프라를 IPv6로 전환할 때 Dual-Stack과 NAT64/DNS64 방식의 차이점과 각각의 적용 시나리오를 설명해주세요.', 'Dual-Stack: 모든 시스템이 IPv4와 IPv6 주소를 동시에 가짐. 장점은 호환성이 가장 좋고 점진적 전환 가능. 단점은 양쪽 네트워크 관리 필요, IPv4 주소 계속 필요. 적용: 장기 전환 과정, IPv4/v6 클라이언트 모두 지원 필요 시. NAT64/DNS64: IPv6 전용 네트워크에서 IPv4 서버 접근. DNS64가 IPv4 주소를 IPv6로 합성하고, NAT64가 프로토콜 변환. 장점은 클라이언트는 IPv6만 사용, IPv4 주소 절약. 단점은 NAT64 장비가 병목이 될 수 있고, 일부 애플리케이션 호환 문제. 적용: 모바일 네트워크(통신사), 새로운 IPv6-only 환경. 클라우드: AWS는 Dual-Stack 서브넷 지원, GCP는 IPv6-only VPC 옵션 제공. 고려사항: 보안그룹/방화벽 IPv6 규칙, 로깅에서 IPv6 주소 처리.', ARRAY['Dual-Stack', 'NAT64', 'DNS64', 'IPv6전환', 'IPv4고갈'], '모바일 통신사들은 IPv4 주소 고갈로 NAT64를 적극 도입하고 있습니다.', 'docs/01-network.md');

-- =============================================
-- LINUX 문제 (25문제) - 시니어급
-- =============================================

-- 1. 프로세스 스케줄링
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'process', 3, 30, 75, '고성능 거래 시스템에서 특정 프로세스의 지연 시간을 최소화하기 위한 CPU 격리(isolcpus)와 실시간 스케줄링(SCHED_FIFO) 적용 방법을 설명해주세요.', 'CPU 격리: 1) 커널 부트 파라미터에 isolcpus=4-7 추가하여 해당 코어를 일반 스케줄러에서 제외 2) taskset -c 4-7 ./trading_app 또는 numactl --physcpubind=4-7로 프로세스를 격리된 코어에 바인딩. 실시간 스케줄링: chrt -f 99 ./trading_app으로 SCHED_FIFO 우선순위 99 적용. 주의: 실시간 프로세스가 무한루프에 빠지면 시스템 먹통, 다른 프로세스 기아 상태. 추가 튜닝: 1) irqbalance 비활성화하고 수동으로 IRQ를 다른 코어에 배치 2) RCU 콜백을 격리 코어에서 제외(rcu_nocbs) 3) NUMA 인식 메모리 할당. 검증: cyclictest로 지연 측정, /proc/interrupts로 격리 코어에 인터럽트 없는지 확인.', ARRAY['isolcpus', 'SCHED_FIFO', 'CPU 격리', 'taskset', '실시간스케줄링'], 'HFT(고빈도거래) 시스템은 마이크로초 단위 지연이 중요하여 이런 커널 레벨 튜닝이 필수입니다.', 'docs/02-linux-os.md');

-- 2. 메모리 할당자
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'memory', 3, 30, 75, '고성능 서버 애플리케이션에서 glibc malloc 대신 jemalloc이나 tcmalloc을 사용할 때의 장점과 설정 방법을 설명해주세요.', 'glibc malloc 한계: 멀티스레드 환경에서 전역 락 경합, 메모리 단편화, 대용량 힙에서 성능 저하. jemalloc 장점: 1) 스레드별 캐시(thread cache)로 락 경합 최소화 2) 크기별 클래스 분리로 단편화 감소 3) 상세 메모리 통계 제공 4) Facebook/Redis 등에서 검증됨. tcmalloc: Google 개발, 유사한 장점에 더해 CPU 사용 최적화. 적용 방법: 1) LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so ./app 2) 컴파일 시 -ljemalloc 링크 3) Docker에서 환경변수로 설정. 튜닝: MALLOC_CONF 환경변수로 아레나 수, dirty page decay time 등 설정. 주의: 기존 앱과 호환성 테스트 필수, 프로파일링 도구 지원 확인.', ARRAY['jemalloc', 'tcmalloc', 'LD_PRELOAD', '메모리할당자', '멀티스레드'], 'Redis는 jemalloc을 기본 할당자로 사용하여 메모리 효율성을 높입니다.', 'docs/02-linux-os.md');

-- 3. 파일 디스크립터 관리
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'filesystem', 3, 30, 75, '대규모 연결을 처리하는 서버에서 "Too many open files" 에러가 발생했습니다. 시스템 및 프로세스 레벨의 제한 확인 방법과 튜닝 방법을 설명해주세요.', '제한 확인: 1) 시스템 전체: cat /proc/sys/fs/file-max, cat /proc/sys/fs/file-nr(사용중/할당/최대) 2) 프로세스별: cat /proc/PID/limits에서 Max open files 확인 3) 현재 사용: ls /proc/PID/fd | wc -l. 튜닝: 시스템 레벨: /etc/sysctl.conf에 fs.file-max = 2097152, fs.nr_open = 2097152. 사용자 레벨: /etc/security/limits.conf에 * soft nofile 1048576, * hard nofile 1048576. systemd 서비스: LimitNOFILE=1048576 설정. 주의: 1) soft < hard < nr_open < file-max 관계 유지 2) 메모리 사용량 고려(FD당 약 1KB) 3) select()는 FD 1024 제한 있으므로 epoll 사용 필수 4) 변경 후 서비스 재시작 또는 재로그인 필요.', ARRAY['file-max', 'ulimit', 'nofile', 'Too many open files', '파일디스크립터'], '대규모 웹서버나 프록시는 수십만 개의 동시 연결을 처리하므로 기본 설정으로는 부족합니다.', 'docs/02-linux-os.md');

-- 4. systemd 의존성
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'systemd', 3, 30, 75, '복잡한 의존 관계를 가진 마이크로서비스들의 systemd 서비스 파일에서 시작 순서와 실패 처리를 올바르게 설정하는 방법을 설명해주세요.', '시작 순서: After=dependency.service는 순서만 정의(dependency 시작 후 시작), Requires/Wants와 조합 필요. Requires: 의존 서비스 실패 시 함께 실패. Wants: 의존 서비스 실패해도 시작 시도. BindsTo: 의존 서비스 중지 시 함께 중지(강한 결합). PartOf: 의존 서비스 재시작 시 함께 재시작. 실패 처리: OnFailure=failure-handler.service로 실패 시 알림/복구 서비스 실행. 예시: [Unit] After=network.target postgresql.service Requires=postgresql.service Wants=redis.service. 검증: systemd-analyze verify로 유닛 파일 검사, systemd-analyze dot으로 의존성 그래프. 주의: 순환 의존성 피하기, Type=notify로 서비스 준비 완료 정확히 알림.', ARRAY['systemd 의존성', 'After', 'Requires', 'Wants', 'BindsTo'], 'After 없이 Requires만 있으면 병렬 시작되어 순서가 보장되지 않습니다.', 'docs/02-linux-os.md');

-- 5. cgroup 리소스 제어
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'cgroup', 3, 30, 75, 'cgroup v2를 사용하여 특정 프로세스 그룹의 메모리 사용량을 제한하고 OOM 발생 시 동작을 제어하는 방법을 설명해주세요.', 'cgroup v2 메모리 제어: 1) /sys/fs/cgroup 아래에 그룹 디렉토리 생성: mkdir /sys/fs/cgroup/myapp 2) 프로세스 추가: echo PID > /sys/fs/cgroup/myapp/cgroup.procs 3) 메모리 제한: echo 512M > /sys/fs/cgroup/myapp/memory.max (하드 리밋), echo 400M > /sys/fs/cgroup/myapp/memory.high (소프트 리밋, 초과 시 스로틀링). OOM 제어: memory.oom.group = 1이면 그룹 내 모든 프로세스 함께 종료. systemd 통합: 서비스 파일에 MemoryMax=512M, MemoryHigh=400M 설정. 모니터링: memory.current(현재 사용), memory.stat(상세 통계), memory.events(OOM 횟수). 주의: v1과 v2 혼용 불가, memory.high 없이 max만 설정하면 갑자기 OOM 발생 가능.', ARRAY['cgroup v2', 'memory.max', 'memory.high', 'OOM', '리소스제어'], 'memory.high는 소프트 리밋으로 메모리 회수 압박을 주어 OOM 전에 경고 역할을 합니다.', 'docs/02-linux-os.md');

-- 6. 커널 파라미터 튜닝
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'kernel', 3, 30, 75, 'vm.swappiness, vm.dirty_ratio, vm.dirty_background_ratio 파라미터가 데이터베이스 서버 성능에 미치는 영향과 권장 설정을 설명해주세요.', 'vm.swappiness: 0-100 범위, 값이 낮을수록 swap 사용 지연. DB는 swap 시 성능 급락하므로 1-10 권장(0은 메모리 압박 시 OOM 위험). vm.dirty_ratio: 전체 메모리 대비 dirty 페이지 비율이 이 값 초과 시 쓰기 프로세스가 동기 I/O로 전환(블로킹). DB는 쓰기 지연 스파이크 방지를 위해 10-15% 권장. vm.dirty_background_ratio: 이 비율 초과 시 백그라운드 플러시 시작. dirty_ratio보다 낮게 설정(5-10%)하여 점진적 쓰기 유도. 추가: vm.dirty_expire_centisecs(dirty 페이지 만료 시간), vm.dirty_writeback_centisecs(플러시 주기). DB별 차이: PostgreSQL은 자체 버퍼 관리하므로 OS 캐시 줄이고 shared_buffers 늘림, MySQL InnoDB도 유사.', ARRAY['swappiness', 'dirty_ratio', 'dirty_background_ratio', 'DB성능', '커널튜닝'], 'dirty_ratio 100%로 설정하면 I/O 폭주 시 모든 쓰기가 블로킹되어 심각한 지연이 발생합니다.', 'docs/02-linux-os.md');

-- 7. 네트워크 스택 튜닝
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'networking', 3, 30, 75, '대규모 웹 서버에서 "listen overflow" 또는 "connection reset" 에러가 발생할 때 관련 커널 파라미터 튜닝 방법을 설명해주세요.', '증상 진단: netstat -s | grep -i listen으로 오버플로우 확인, dmesg에서 "TCP: request_sock_TCP" 메시지. 튜닝 파라미터: 1) net.core.somaxconn = 65535 (listen backlog 최대값) 2) net.ipv4.tcp_max_syn_backlog = 65535 (SYN 큐 크기) 3) net.core.netdev_max_backlog = 65535 (NIC 수신 큐) 4) net.ipv4.tcp_abort_on_overflow = 0 (오버플로우 시 RST 대신 재시도 허용). 애플리케이션 설정: listen(fd, backlog)의 backlog 값도 증가 필요. SYN Flood 대응: net.ipv4.tcp_syncookies = 1. 검증: ss -ltn으로 Send-Q(backlog 크기)와 Recv-Q(현재 대기 연결) 확인. 주의: 메모리 사용량 증가, 실제 처리 능력 없이 큐만 늘리면 지연만 증가.', ARRAY['somaxconn', 'tcp_max_syn_backlog', 'listen overflow', 'SYN큐', '커넥션백로그'], 'Nginx, Apache 등 웹서버 설정의 backlog 값도 커널 설정과 함께 조정해야 합니다.', 'docs/02-linux-os.md');

-- 8. 디스크 I/O 스케줄러
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'storage', 3, 30, 75, 'NVMe SSD, SATA SSD, HDD 각각에 적합한 I/O 스케줄러 선택 기준과 변경 방법을 설명해주세요.', 'NVMe SSD: none(noop) 스케줄러 권장. NVMe는 하드웨어가 충분히 빠르고 자체 큐 관리하므로 소프트웨어 스케줄러 오버헤드 불필요. SATA SSD: mq-deadline 또는 none. 랜덤 I/O에 강하지만 약간의 스케줄링이 SATA 인터페이스에서 도움될 수 있음. HDD: mq-deadline(지연 시간 보장, DB용) 또는 bfq(데스크톱, 공정성). 회전 디스크는 seek 시간 최소화가 중요. 확인/변경: cat /sys/block/sda/queue/scheduler (대괄호가 현재 설정), echo mq-deadline > /sys/block/sda/queue/scheduler. 영구 설정: udev 규칙 또는 /etc/default/grub에 elevator=none. 커널 5.0+는 blk-mq 기반으로 기존 cfq, deadline은 mq 버전으로 대체됨.', ARRAY['I/O 스케줄러', 'mq-deadline', 'bfq', 'none', 'NVMe'], 'NVMe에서 복잡한 스케줄러 사용 시 오히려 성능 저하가 발생할 수 있습니다.', 'docs/02-linux-os.md');

-- 9. SELinux 트러블슈팅
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'security', 3, 30, 75, '웹 서버가 특정 디렉토리의 파일을 읽지 못하는데 일반 권한은 정상입니다. SELinux가 원인인지 확인하고 해결하는 방법을 설명해주세요.', 'SELinux 확인: 1) getenforce로 모드 확인 (Enforcing/Permissive/Disabled) 2) ausearch -m avc -ts recent 또는 grep denied /var/log/audit/audit.log로 거부 로그 확인. 문제 진단: ls -Z /path/to/file로 파일의 SELinux 컨텍스트 확인. 웹 서버는 httpd_sys_content_t 레이블 필요. 해결: 1) 올바른 컨텍스트 설정: semanage fcontext -a -t httpd_sys_content_t "/custom/path(/.*)?" && restorecon -Rv /custom/path 2) 특정 boolean 활성화: setsebool -P httpd_can_network_connect on 3) 임시 테스트: setenforce 0으로 Permissive 전환 후 동작 확인. 도구: audit2why로 거부 원인 분석, audit2allow로 정책 생성. 주의: 무분별한 Permissive 사용 지양, 필요한 정책만 추가.', ARRAY['SELinux', 'ausearch', 'semanage', 'restorecon', 'httpd_sys_content_t'], 'chcon은 임시 변경으로 재레이블링 시 사라집니다. semanage + restorecon으로 영구 설정하세요.', 'docs/02-linux-os.md');

-- 10. 로그 관리
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'logs', 3, 30, 75, 'journald와 rsyslog를 함께 사용하는 환경에서 로그 저장 정책을 설계하고 디스크 공간 관리 방법을 설명해주세요.', 'journald 설정 (/etc/systemd/journald.conf): Storage=persistent (디스크 저장), SystemMaxUse=2G (최대 크기), SystemMaxFileSize=128M (파일당 크기), MaxRetentionSec=1month (보관 기간). rsyslog 연동: journald에서 rsyslog로 전달 (ForwardToSyslog=yes) 후 rsyslog에서 파일 분리/원격 전송. logrotate 설정: /etc/logrotate.d/에서 각 로그 파일의 로테이션 주기, 보관 개수, 압축 설정. 예: daily, rotate 7, compress, delaycompress. 공간 관리: 1) journalctl --vacuum-size=1G (즉시 정리) 2) journalctl --vacuum-time=7d (기간 기준) 3) logrotate -f /etc/logrotate.conf (강제 로테이션). 모니터링: df -h /var/log, du -sh /var/log/journal. 고려사항: 중요 로그는 원격 저장소(ELK, CloudWatch Logs)로 전송.', ARRAY['journald', 'rsyslog', 'logrotate', '로그관리', '디스크공간'], '/var/log/journal 디렉토리가 없으면 journald는 /run/log/journal에 임시 저장만 합니다.', 'docs/02-linux-os.md');

-- 11. 네임스페이스 활용
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'containers', 3, 30, 75, '컨테이너 없이 리눅스 namespace만을 사용하여 네트워크 격리 환경을 만드는 방법과 실제 사용 사례를 설명해주세요.', '네트워크 네임스페이스 생성: ip netns add myns. 가상 이더넷 쌍 생성: ip link add veth0 type veth peer name veth1, ip link set veth1 netns myns. IP 할당: ip addr add 192.168.1.1/24 dev veth0 (호스트), ip netns exec myns ip addr add 192.168.1.2/24 dev veth1 (네임스페이스). 활성화: ip link set veth0 up, ip netns exec myns ip link set veth1 up. 네임스페이스 내 실행: ip netns exec myns bash. 사용 사례: 1) 네트워크 테스트 환경 구축 2) VPN 클라이언트 격리 3) 멀티 테넌트 네트워크 시뮬레이션 4) 컨테이너 런타임의 네트워크 구현 기반. 삭제: ip netns delete myns. 참고: unshare --net은 새 프로세스에 격리된 네트워크 생성.', ARRAY['network namespace', 'ip netns', 'veth', 'unshare', '네트워크격리'], 'Docker와 Kubernetes의 네트워크 격리도 내부적으로 이런 namespace와 veth를 사용합니다.', 'docs/02-linux-os.md');

-- 12. 성능 프로파일링
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'performance', 3, 30, 75, 'perf를 사용하여 CPU 바운드 애플리케이션의 성능 병목을 찾고 플레임 그래프를 생성하는 전체 과정을 설명해주세요.', '데이터 수집: perf record -g -p PID --call-graph dwarf sleep 30 (30초간 PID 프로세스 프로파일링, DWARF 콜스택). 또는 전체 시스템: perf record -g -a sleep 30. 분석: perf report -g --stdio (텍스트), perf report (대화형). 핫스팟 확인: 가장 많은 샘플이 수집된 함수가 병목. 플레임 그래프 생성: perf script > out.perf, stackcollapse-perf.pl out.perf > out.folded, flamegraph.pl out.folded > flamegraph.svg (FlameGraph 도구 필요). 해석: x축 넓이가 CPU 시간 비율, y축이 콜스택 깊이, 넓은 "고원"이 최적화 대상. 추가 분석: perf stat ./app으로 IPC, 캐시 미스 등 하드웨어 카운터 확인. 주의: -g 옵션 없으면 콜스택 없음, 컴파일 시 -fno-omit-frame-pointer 권장.', ARRAY['perf', 'flame graph', 'perf record', 'perf report', 'CPU프로파일링'], '플레임 그래프는 Brendan Gregg가 개발한 시각화 도구로 성능 분석의 표준이 되었습니다.', 'docs/02-linux-os.md');

-- 13. 시스템콜 분석
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'kernel', 3, 30, 75, 'strace를 사용하여 프로덕션 서버의 성능 문제를 진단할 때 주의사항과 효과적인 사용 패턴을 설명해주세요.', '주의사항: strace는 ptrace 기반으로 시스템콜마다 컨텍스트 스위칭 발생, 성능 오버헤드 심함(10-100배 느려질 수 있음). 프로덕션에서는 짧은 시간만 사용. 효과적 패턴: 1) -p PID로 실행 중 프로세스 attach 2) -c로 통계만 수집(오버헤드 감소): strace -c -p PID 3) -e trace=로 특정 시스템콜만: strace -e trace=open,read,write 4) -T로 각 콜 소요 시간: strace -T -e trace=read 5) -f로 자식 프로세스 포함. 대안: 프로덕션에서는 perf trace(더 가벼움) 또는 eBPF 기반 도구(bpftrace, bcc) 사용. 분석 예: open 실패가 많으면 파일 경로 문제, read가 많으면 버퍼링 부족, futex가 많으면 락 경합.', ARRAY['strace', 'ptrace', 'perf trace', 'bpftrace', '시스템콜추적'], '프로덕션에서 strace 대신 bpftrace로 시스템콜 분석이 가능합니다.', 'docs/02-linux-os.md');

-- 14. LVM 스냅샷
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'storage', 3, 30, 75, 'LVM 스냅샷을 활용한 데이터베이스 백업 전략과 스냅샷 사용 시 성능 영향 및 주의사항을 설명해주세요.', '백업 전략: 1) DB에서 FLUSH TABLES WITH READ LOCK (또는 일관성 지점 생성) 2) lvcreate -L 10G -s -n db_snap /dev/vg/db_lv (스냅샷 생성) 3) 락 해제 4) 스냅샷 마운트하여 백업 수행 5) lvremove /dev/vg/db_snap으로 스냅샷 삭제. 성능 영향: LVM 스냅샷은 Copy-on-Write 방식으로 원본 변경 시 이전 데이터를 스냅샷 볼륨에 복사. 스냅샷 존재 시 쓰기 성능 저하(2-3배). 주의사항: 1) 스냅샷 볼륨 크기 충분히 할당(변경량 예측) 2) 스냅샷 볼륨 100% 차면 자동 해제되어 데이터 손실 3) 오래 유지할수록 성능 영향 증가 4) thin provisioning LVM은 더 효율적. 대안: ZFS, Btrfs의 네이티브 스냅샷이 성능 영향 적음.', ARRAY['LVM 스냅샷', 'lvcreate', 'Copy-on-Write', 'DB백업', '스냅샷성능'], 'LVM 스냅샷은 장시간 유지용이 아닌 빠른 백업 후 삭제 용도로 적합합니다.', 'docs/02-linux-os.md');

-- 15. eBPF 모니터링
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'kernel', 3, 30, 75, 'bcc tools의 biolatency, tcplife, opensnoop을 사용하여 프로덕션 서버의 성능 문제를 진단하는 방법을 설명해주세요.', 'biolatency: 블록 I/O 지연 히스토그램 표시. biolatency -D로 디바이스별 분리. 사용 예: I/O 지연 스파이크 원인 파악, 디스크 문제 vs 소프트웨어 문제 구분. tcplife: TCP 연결의 수명과 바이트 전송량 추적. 짧은 연결이 많으면 연결 재사용 부족, 특정 호스트로 대량 트래픽이면 이상 징후. opensnoop: 파일 열기 시스템콜 추적. 설정 파일 위치 문제, 존재하지 않는 파일 반복 접근, 숨겨진 의존성 발견에 유용. 공통 장점: 1) 프로덕션에서 안전(커널 verifier) 2) 낮은 오버헤드 3) 재부팅 불필요. 활용 패턴: 문제 발생 시 관련 도구 실행하여 실시간 데이터 수집, 히스토그램으로 분포 확인, 특이값(outlier) 추적.', ARRAY['bcc tools', 'biolatency', 'tcplife', 'opensnoop', 'eBPF'], 'bcc tools는 수십 가지 도구를 제공하며 대부분 한 줄 명령으로 즉시 사용 가능합니다.', 'docs/02-linux-os.md');

-- 16. RAID 복구
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'storage', 3, 30, 75, 'mdadm으로 구성된 RAID 어레이에서 디스크 장애 감지 방법과 디스크 교체 후 리빌드 과정을 설명해주세요.', '장애 감지: 1) cat /proc/mdstat에서 [UUU_] 형태로 실패 디스크 표시 2) mdadm --detail /dev/md0에서 State: degraded 확인 3) dmesg에서 I/O 에러 메시지 4) smartctl -a /dev/sdb로 SMART 상태. 디스크 제거: mdadm --manage /dev/md0 --fail /dev/sdb1 (실패 마킹), mdadm --manage /dev/md0 --remove /dev/sdb1 (제거). 새 디스크 추가: 1) 파티션 생성 (기존과 동일) 2) mdadm --manage /dev/md0 --add /dev/sdc1 3) 자동 리빌드 시작, /proc/mdstat에서 진행률 확인. 리빌드 중 주의: I/O 성능 저하, 추가 장애 시 데이터 손실 위험 증가. 리빌드 속도 조정: /proc/sys/dev/raid/speed_limit_min, speed_limit_max. 예방: 정기적 SMART 모니터링, 핫스페어 구성(mdadm --add --spare).', ARRAY['mdadm', 'RAID 리빌드', '/proc/mdstat', 'SMART', '핫스페어'], 'RAID5에서 리빌드 중 두 번째 디스크 장애는 전체 데이터 손실을 의미합니다.', 'docs/02-linux-os.md');

-- 17. 부팅 프로세스
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'systemd', 3, 30, 75, '시스템 부팅이 비정상적으로 오래 걸릴 때 systemd-analyze를 사용한 진단 방법과 부팅 시간 최적화 전략을 설명해주세요.', '진단 명령: 1) systemd-analyze: 전체 부팅 시간 표시 2) systemd-analyze blame: 서비스별 시작 시간 내림차순 3) systemd-analyze critical-chain: 크리티컬 패스 시각화 4) systemd-analyze plot > boot.svg: 타임라인 그래프. 최적화 전략: 1) 불필요한 서비스 disable: systemctl disable unneeded.service 2) 느린 서비스 최적화 또는 병렬화 3) Type=notify 사용으로 준비 완료 정확히 알림 4) Socket Activation: 서비스를 요청 시점에 시작 5) DefaultDependencies=no로 불필요한 의존성 제거 6) 디스크 I/O 병목 해결(SSD, fsck 최적화). 주의: 무분별한 disable은 기능 장애 유발, 의존성 확인 필수. 마스크: systemctl mask로 완전 비활성화(다른 서비스가 시작 불가).', ARRAY['systemd-analyze', 'blame', 'critical-chain', '부팅최적화', 'Socket Activation'], 'Socket Activation은 서비스가 실제로 필요할 때만 시작하여 부팅 시간과 리소스를 절약합니다.', 'docs/02-linux-os.md');

-- 18. Capabilities 활용
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'security', 3, 30, 75, '비특권 사용자가 실행하는 웹 서버가 1024 이하 포트를 사용해야 할 때 setuid root 대신 Capabilities를 사용하는 방법을 설명해주세요.', 'setuid root 문제: 전체 root 권한을 부여하여 취약점 발생 시 시스템 전체 침해 위험. Capabilities 해결: CAP_NET_BIND_SERVICE만 부여하면 1024 이하 포트 바인딩만 가능. 설정 방법: setcap ''cap_net_bind_service=+ep'' /usr/bin/mywebserver (e=effective, p=permitted). 확인: getcap /usr/bin/mywebserver. 주의사항: 1) 스크립트에는 직접 적용 불가(인터프리터에 적용 필요하나 위험) 2) 파일 시스템이 capabilities 지원해야 함(nosuid 옵션 불가) 3) LD_LIBRARY_PATH가 무시됨(보안상). 추가 capability 예: CAP_NET_RAW(ping, tcpdump), CAP_SYS_PTRACE(strace), CAP_DAC_OVERRIDE(파일 권한 무시). systemd에서: AmbientCapabilities=CAP_NET_BIND_SERVICE 설정.', ARRAY['Capabilities', 'CAP_NET_BIND_SERVICE', 'setcap', 'getcap', '최소권한'], 'Docker --cap-drop=ALL --cap-add=필요한것만 으로 컨테이너 권한도 최소화할 수 있습니다.', 'docs/02-linux-os.md');

-- 19. 감사 로깅
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'security', 3, 30, 75, 'auditd를 사용하여 중요 파일 접근과 권한 상승 시도를 모니터링하는 규칙 설정 방법을 설명해주세요.', '파일 모니터링 규칙: auditctl -w /etc/passwd -p rwa -k passwd_changes (r=read, w=write, a=attribute). 또는 /etc/audit/rules.d/audit.rules에 -w /etc/passwd -p wa -k passwd_changes 추가. 권한 상승 모니터링: -a always,exit -F arch=b64 -S execve -F euid=0 -F auid>=1000 -k privilege_escalation (일반 사용자가 root 권한으로 실행). 시스템콜 모니터링: -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -k permission_changes. 로그 분석: ausearch -k passwd_changes, aureport -k로 키별 요약. 실시간 알림: auditd -> rsyslog -> SIEM 연동. 주의: 과도한 규칙은 성능 영향과 로그 폭증, 핵심 이벤트만 선별. 변경 적용: augenrules --load 또는 service auditd restart.', ARRAY['auditd', 'auditctl', 'ausearch', 'aureport', '감사로깅'], 'PCI-DSS, HIPAA 등 컴플라이언스 요구사항은 특정 파일에 대한 감사 로깅을 필수로 합니다.', 'docs/02-linux-os.md');

-- 20. 시간 동기화
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'systemd', 3, 30, 75, '분산 시스템에서 시간 동기화의 중요성과 chrony를 사용한 고정밀 시간 동기화 설정 방법을 설명해주세요.', '중요성: 1) 로그 상관관계 분석에 시간 일관성 필수 2) 분산 DB(Spanner), 합의 알고리즘에서 시간 기반 순서 보장 3) TLS 인증서 유효성 검증 4) 크론잡 정확한 실행. chrony 설정 (/etc/chrony.conf): server time.google.com iburst (빠른 초기 동기화), pool ntp.ubuntu.com iburst, makestep 1.0 3 (3번 체크 후 1초 이상 차이면 즉시 조정). 고정밀 설정: 1) 여러 NTP 서버 지정 2) hwclock 연동으로 하드웨어 시계도 동기화 3) PTP(Precision Time Protocol)는 마이크로초 정밀도. 상태 확인: chronyc tracking (오프셋, 정밀도), chronyc sources (서버별 상태). AWS: Amazon Time Sync Service(169.254.169.123)가 인스턴스에 최적화.', ARRAY['chrony', 'NTP', '시간동기화', 'PTP', 'makestep'], '클라우드 환경에서 VM 마이그레이션 후 시간 드리프트가 발생할 수 있어 chrony가 ntpd보다 적응력이 좋습니다.', 'docs/02-linux-os.md');

-- 21. 파일시스템 마운트 옵션
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'filesystem', 3, 30, 75, '보안과 성능을 고려한 /etc/fstab 마운트 옵션 설정과 각 옵션의 의미를 설명해주세요.', '보안 옵션: noexec(실행 파일 실행 금지, /tmp에 권장), nosuid(SUID/SGID 무시), nodev(디바이스 파일 해석 안 함), ro(읽기 전용). 성능 옵션: noatime(접근 시간 업데이트 안 함, I/O 감소), nodiratime(디렉토리 접근 시간), relatime(하루 1회 업데이트, 기본값). 예시: /tmp - noexec,nosuid,nodev로 악성 스크립트 실행 방지, /home - nosuid,nodev, /var/log - noexec,nosuid,nodev. ext4 옵션: data=ordered(기본, 안전), data=writeback(빠름, 위험), barrier=1(쓰기 배리어, 무결성). XFS: largeio(대용량 I/O 최적화), inode64. 클라우드 볼륨: discard 또는 fstrim 크론으로 TRIM/UNMAP 지원. 적용: mount -o remount,옵션 /path 또는 재마운트.', ARRAY['fstab', 'noexec', 'nosuid', 'noatime', '마운트옵션'], 'CIS Benchmark는 /tmp, /var/tmp에 noexec,nosuid,nodev 마운트를 권장합니다.', 'docs/02-linux-os.md');

-- 22. 커널 모듈 관리
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'kernel', 3, 30, 75, '보안을 위해 불필요한 커널 모듈을 비활성화하고 모듈 로딩을 제한하는 방법을 설명해주세요.', '모듈 비활성화: 1) 즉시: modprobe -r module_name (언로드) 2) 영구: /etc/modprobe.d/blacklist.conf에 blacklist module_name 또는 install module_name /bin/true (로드 시도 시 아무것도 안 함). 일반적 비활성화 대상: USB 저장장치(usb-storage) - 데이터 유출 방지, 불필요 파일시스템(cramfs, freevxfs, jffs2, hfs, hfsplus, squashfs, udf), 불필요 네트워크 프로토콜(dccp, sctp, rds, tipc). 모듈 로딩 완전 차단: kernel.modules_disabled=1 (sysctl, 부팅 후 설정하면 이후 모듈 로드 불가, 재부팅 필요). 서명된 모듈만 허용: CONFIG_MODULE_SIG_FORCE=y (커널 컴파일 옵션). 확인: lsmod로 로드된 모듈, /proc/modules 또는 /sys/module/.', ARRAY['modprobe', 'blacklist', 'modules_disabled', '커널모듈', '보안하드닝'], 'CIS Benchmark와 보안 가이드라인은 불필요한 커널 모듈 비활성화를 권장합니다.', 'docs/02-linux-os.md');

-- 23. 프로세스 리소스 추적
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'process', 3, 30, 75, '/proc 파일시스템을 직접 활용하여 특정 프로세스의 메모리 매핑, 파일 디스크립터, CPU 사용률을 상세히 분석하는 방법을 설명해주세요.', '메모리 매핑: /proc/PID/maps - 가상 메모리 영역 목록(주소, 권한, 파일 매핑), /proc/PID/smaps - 각 영역의 RSS, PSS, Shared/Private 상세 정보, /proc/PID/status의 VmRSS, VmSize. 파일 디스크립터: ls -l /proc/PID/fd/ - 열린 파일/소켓/파이프, /proc/PID/fdinfo/N - FD별 상세(오프셋, 플래그). CPU 사용률: /proc/PID/stat의 14번째(utime), 15번째(stime) 필드 - 클럭 틱 단위 CPU 시간, /proc/stat의 CPU 라인과 비교하여 비율 계산. 계산: (현재utime+stime - 이전utime+stime) / (현재total_cpu - 이전total_cpu). I/O 통계: /proc/PID/io - read_bytes, write_bytes. 활용 예: 메모리 누수 추적(smaps의 [heap] 증가), FD 누수(fd 개수 증가), CPU 핫 프로세스 식별.', ARRAY['/proc', 'smaps', 'fd', 'stat', '프로세스분석'], '모니터링 도구(top, htop)도 내부적으로 /proc 파일시스템을 읽어 정보를 표시합니다.', 'docs/02-linux-os.md');

-- 24. 디스크 쿼터
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'filesystem', 3, 30, 75, '멀티 테넌트 환경에서 사용자/그룹별 디스크 사용량을 제한하기 위한 쿼터 설정 방법과 모니터링 방법을 설명해주세요.', '쿼터 활성화: 1) /etc/fstab에 usrquota,grpquota 옵션 추가, 재마운트 2) quotacheck -cugm /mountpoint (쿼터 파일 생성) 3) quotaon -avug (활성화). 쿼터 설정: edquota -u username (사용자별), edquota -g groupname (그룹별). 설정 항목: soft limit(경고, grace period 내 초과 허용), hard limit(절대 제한), inode limit(파일 개수 제한). 확인: quota -u username, repquota -a (전체 리포트). 경고 설정: warnquota로 이메일 알림. 프로젝트 쿼터(XFS): xfs_quota로 디렉토리 단위 쿼터 가능. cgroup v2: io.max로 I/O 대역폭 제한(디스크 공간이 아닌 I/O 속도). 클라우드: EBS 볼륨 크기나 EFS 버스팅 제한으로 물리적 제한, 애플리케이션 레벨 쿼터도 고려.', ARRAY['quota', 'edquota', 'repquota', 'usrquota', '디스크제한'], 'soft limit 초과 후 grace period(기본 7일) 내 해결하지 않으면 hard limit처럼 동작합니다.', 'docs/02-linux-os.md');

-- 25. 컨테이너 런타임 분석
INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc) VALUES
('linux', 'containers', 3, 30, 75, '컨테이너 내부에서 발생하는 문제를 호스트에서 진단하기 위한 nsenter, crictl 활용 방법과 디버깅 전략을 설명해주세요.', 'nsenter 활용: 컨테이너 PID 확인 후 해당 namespace에 진입. nsenter -t PID --net ip addr (네트워크 namespace), nsenter -t PID --pid --mount ps aux (PID와 마운트 namespace). Kubernetes: crictl ps로 컨테이너 ID 확인, crictl inspect CONTAINER_ID로 PID 획득. 디버깅 전략: 1) 네트워크 문제: nsenter --net으로 진입 후 ss, ip route, tcpdump 2) 파일 문제: nsenter --mount로 컨테이너 파일시스템 접근 3) 프로세스 문제: /proc/컨테이너PID/root에서 컨테이너 루트 접근. 도구 없는 컨테이너: kubectl debug로 ephemeral container 추가하거나 호스트에서 nsenter 사용. 주의: 일부 도구는 컨테이너 내 없을 수 있어 호스트 도구로 namespace 진입이 유용. crictl logs, crictl exec도 기본 디버깅에 활용.', ARRAY['nsenter', 'crictl', 'namespace', '컨테이너디버깅', 'ephemeral container'], 'kubectl debug --target=pod은 Kubernetes 1.23+에서 사용 가능한 강력한 디버깅 기능입니다.', 'docs/02-linux-os.md');
