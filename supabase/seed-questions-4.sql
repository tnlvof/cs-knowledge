-- =====================================================
-- CS Knowledge Quiz - Architecture & Incident Questions
-- =====================================================
-- 분야별 문제 수:
--   - Architecture (아키텍처/확장성): 50문제
--   - Incident (장애대응/SRE): 50문제
-- 총 문제 수: 100문제
--
-- 난이도 분배 (분야당):
--   - 난이도 1 (입문): ~15문제
--   - 난이도 2 (주니어): ~15문제
--   - 난이도 3 (시니어): ~12문제
--   - 난이도 4 (리드): ~8문제
-- =====================================================

INSERT INTO questions (category, subcategory, difficulty, level_min, level_max, question_text, correct_answer, keywords, explanation, source_doc)
VALUES

-- =====================================================
-- ARCHITECTURE (아키텍처/확장성) - 50문제
-- =====================================================

-- 난이도 1 (입문) - 15문제
('architecture', '모놀리스 vs 마이크로서비스', 1, 1, 25,
 '모놀리스 아키텍처란 무엇인가요?',
 '모놀리스 아키텍처는 모든 기능이 단일 애플리케이션으로 통합된 구조입니다. 하나의 코드베이스, 하나의 배포 단위, 하나의 데이터베이스를 공유하며, 모든 컴포넌트가 단일 프로세스로 실행됩니다.',
 ARRAY['단일 애플리케이션', '하나의 코드베이스', '하나의 배포 단위', '통합 구조', '단일 프로세스'],
 '모놀리스는 초기 개발이 단순하고 빠르지만, 규모가 커지면 복잡도가 증가하고 확장이 어려워질 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '모놀리스 vs 마이크로서비스', 1, 1, 25,
 '마이크로서비스 아키텍처의 장점을 설명하세요.',
 '마이크로서비스의 장점은 서비스별 독립 배포가 가능하고, 기술 스택을 자유롭게 선택할 수 있으며, 장애가 격리되고, 팀별로 독립적으로 개발할 수 있으며, 서비스별로 개별 확장이 가능하다는 것입니다.',
 ARRAY['독립 배포', '기술 스택 자유', '장애 격리', '독립 개발', '개별 확장'],
 '마이크로서비스는 대규모 팀과 복잡한 시스템에서 효과적이지만, 분산 시스템의 복잡성을 관리해야 합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API 설계', 1, 1, 25,
 'REST API에서 주요 HTTP 메서드의 용도를 설명하세요.',
 'GET은 조회, POST는 생성, PUT은 전체 수정, PATCH는 부분 수정, DELETE는 삭제에 사용됩니다. GET, PUT, DELETE는 멱등성을 가지며, GET은 안전한(safe) 메서드입니다.',
 ARRAY['GET', 'POST', 'PUT', 'PATCH', 'DELETE', '멱등성'],
 '멱등성은 같은 요청을 여러 번 해도 결과가 동일한 것을 의미합니다. POST는 비멱등 메서드입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API 설계', 1, 1, 25,
 '자주 사용하는 HTTP 상태 코드를 설명하세요.',
 '200은 성공, 201은 생성됨, 400은 잘못된 요청, 401은 인증 필요, 403은 권한 없음, 404는 리소스 없음, 500은 서버 오류를 의미합니다. 2xx는 성공, 4xx는 클라이언트 오류, 5xx는 서버 오류입니다.',
 ARRAY['200', '201', '400', '401', '403', '404', '500'],
 '상태 코드는 클라이언트에게 요청 결과를 명확하게 전달하는 중요한 수단입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '메시지 큐', 1, 1, 25,
 '메시지 큐를 사용하는 이유는 무엇인가요?',
 '메시지 큐는 비동기 처리로 응답 시간을 단축하고, 시스템 간 결합도를 감소시키며, 피크 트래픽을 흡수하여 부하를 조절하고, 장애를 격리하며, 실패 시 재처리를 용이하게 합니다.',
 ARRAY['비동기 처리', '결합도 감소', '부하 조절', '장애 격리', '재처리'],
 'Kafka, RabbitMQ, SQS 등 다양한 메시지 큐 솔루션이 있으며, 용도에 맞게 선택합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '이벤트 드리븐', 1, 1, 25,
 '이벤트와 커맨드의 차이점은 무엇인가요?',
 '커맨드는 "~을 해라"라는 명령으로 특정 대상에게 보내는 것이고, 이벤트는 "~이 발생했다"라는 사실로 누가 구독할지 모르는 상태로 발행됩니다. 커맨드는 명령형, 이벤트는 과거형으로 명명합니다.',
 ARRAY['커맨드', '이벤트', '명령', '사실', '발행', '구독'],
 '이벤트 드리븐 아키텍처에서 이 구분은 시스템 설계의 핵심입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CQRS', 1, 1, 25,
 'CQRS란 무엇인가요?',
 'CQRS(Command Query Responsibility Segregation)는 데이터 변경(Command)과 데이터 조회(Query)를 위한 모델을 분리하는 아키텍처 패턴입니다. 각 모델을 독립적으로 최적화할 수 있어 복잡한 도메인에서 유용합니다.',
 ARRAY['CQRS', 'Command', 'Query', '분리', '모델', '최적화'],
 'CQRS는 이벤트 소싱과 자주 결합되어 사용됩니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '캐싱 아키텍처', 1, 1, 25,
 '캐시를 어디에 배치할 수 있나요?',
 '캐시는 브라우저, CDN, 로드밸런서/리버스프록시, 애플리케이션(로컬/분산), 데이터베이스 등 여러 계층에 배치할 수 있습니다. 사용자에 가까울수록 응답이 빠릅니다.',
 ARRAY['브라우저', 'CDN', '로드밸런서', '애플리케이션 캐시', '분산 캐시', 'Redis'],
 '멀티 레이어 캐시 전략을 통해 DB 부하를 최소화할 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '스케일링', 1, 1, 25,
 '수직 확장(Scale Up)과 수평 확장(Scale Out)의 차이점을 설명하세요.',
 '수직 확장은 서버의 CPU, 메모리, 디스크를 증가시키는 것으로 구성이 단순하지만 하드웨어 한계가 있습니다. 수평 확장은 서버 수를 늘리는 것으로 이론적으로 무한 확장이 가능하지만 애플리케이션이 상태 비저장(Stateless)이어야 합니다.',
 ARRAY['수직 확장', '수평 확장', 'Scale Up', 'Scale Out', 'Stateless', '하드웨어 한계'],
 '현대 클라우드 환경에서는 수평 확장과 자동 스케일링이 일반적입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CAP 정리', 1, 1, 25,
 'CAP 정리에서 C, A, P는 각각 무엇을 의미하나요?',
 'C(Consistency)는 모든 노드가 같은 시점에 같은 데이터를 보는 것, A(Availability)는 모든 요청이 응답을 받는 것, P(Partition Tolerance)는 네트워크 분할이 발생해도 시스템이 동작하는 것을 의미합니다.',
 ARRAY['Consistency', 'Availability', 'Partition Tolerance', '일관성', '가용성', '분할 내성'],
 'CAP 정리는 분산 시스템에서 세 가지 속성 중 최대 두 가지만 보장할 수 있다는 이론입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '서비스 메시', 1, 1, 25,
 '서비스 메시가 필요한 이유는 무엇인가요?',
 '마이크로서비스 수가 늘어나면 서비스 간 통신 관리가 복잡해집니다. 디스커버리, 로드 밸런싱, 보안, 모니터링을 각 서비스에 구현하면 중복과 복잡성이 증가하므로, 서비스 메시로 이를 중앙에서 처리합니다.',
 ARRAY['서비스 메시', '마이크로서비스', '통신 관리', '디스커버리', '로드 밸런싱', 'mTLS'],
 'Istio, Linkerd 등이 대표적인 서비스 메시 솔루션입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '서버리스', 1, 1, 25,
 '서버리스의 장단점을 설명하세요.',
 '장점은 서버 관리 불필요, 자동 확장, 사용량 기반 과금, 빠른 배포입니다. 단점은 콜드 스타트 지연, 실행 시간 제한, 상태 유지 어려움, 벤더 종속, 로컬 개발/디버깅 어려움입니다.',
 ARRAY['서버리스', '자동 확장', '콜드 스타트', '벤더 종속', 'FaaS', 'Lambda'],
 '서버리스는 "서버가 없다"가 아니라 "서버를 관리하지 않는다"는 의미입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'DDD', 1, 1, 25,
 '유비쿼터스 언어(Ubiquitous Language)란 무엇인가요?',
 '유비쿼터스 언어는 개발자와 도메인 전문가가 공유하는 공통 용어입니다. 코드, 문서, 대화에서 동일한 용어를 사용하여 의사소통 오해를 방지합니다.',
 ARRAY['유비쿼터스 언어', 'DDD', '공통 용어', '도메인 전문가', '의사소통'],
 'DDD(Domain-Driven Design)의 핵심 개념 중 하나입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '12-Factor App', 1, 1, 25,
 '12-Factor App이란 무엇인가요?',
 '12-Factor App은 확장 가능하고 유지보수하기 쉬운 SaaS 애플리케이션을 만들기 위한 12가지 원칙입니다. 클라우드 환경에 최적화된 설계 지침으로, 환경 간 이식성과 CI/CD 친화적인 특성을 제공합니다.',
 ARRAY['12-Factor', 'SaaS', '클라우드 네이티브', '이식성', 'CI/CD'],
 'Heroku 개발자들이 정리한 방법론으로, 현대 클라우드 애플리케이션의 기본 원칙입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API Gateway', 1, 1, 25,
 'API Gateway의 주요 기능은 무엇인가요?',
 'API Gateway는 요청 라우팅, 인증/인가, Rate Limiting, 요청/응답 변환, 로드 밸런싱, SSL 종료, 캐싱, 로깅/모니터링 등의 기능을 제공합니다.',
 ARRAY['API Gateway', '라우팅', '인증', 'Rate Limiting', 'SSL 종료', '캐싱'],
 'AWS API Gateway, Kong, NGINX Plus 등이 대표적인 솔루션입니다.',
 'docs/07-architecture-scalability.md'),

-- 난이도 2 (주니어) - 15문제
('architecture', '모놀리스 vs 마이크로서비스', 2, 10, 50,
 '모듈러 모놀리스(Modular Monolith)란 무엇인가요?',
 '모듈러 모놀리스는 모놀리스의 단순함을 유지하면서 내부를 모듈로 분리한 구조입니다. 모듈 간 명확한 경계와 인터페이스를 정의하여 추후 마이크로서비스로의 전환이 용이합니다.',
 ARRAY['모듈러 모놀리스', '모듈 분리', '인터페이스', '마이크로서비스 전환', '경계'],
 '스타트업에서 초기에는 모놀리스로 시작하고 점진적으로 분리하는 전략에 적합합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API 설계', 2, 10, 50,
 '페이지네이션 구현 방식의 종류와 특징을 설명하세요.',
 'Offset 기반(page=1&limit=20)은 구현이 단순하지만 대용량에서 성능이 저하됩니다. Cursor 기반(after=id123)은 대용량에 효율적이며 데이터 변경에 강합니다. 응답에 총 개수, 다음 페이지 링크를 포함하는 것이 좋습니다.',
 ARRAY['페이지네이션', 'Offset', 'Cursor', '대용량', '성능'],
 'Cursor 기반은 특히 무한 스크롤 UI에서 많이 사용됩니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API 설계', 2, 10, 50,
 'API 버전 관리 방법을 설명하세요.',
 'URL 경로(/v1/users), 헤더(Accept: application/vnd.api.v1+json), 쿼리 파라미터(?version=1) 방식이 있습니다. URL 방식이 가장 직관적이고 널리 사용됩니다.',
 ARRAY['API 버전', 'URL 경로', '헤더', '쿼리 파라미터', '하위 호환성'],
 '버전 변경 시 하위 호환성을 유지하고 폐기(Deprecation) 정책을 명확히 해야 합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '메시지 큐', 2, 10, 50,
 'Kafka의 Partition과 Consumer Group이란 무엇인가요?',
 'Partition은 Topic을 물리적으로 분할한 단위로, 순서 보장은 Partition 내에서만 됩니다. Consumer Group은 같은 그룹 내 Consumer들이 Partition을 나눠서 처리하며, 그룹 단위로 오프셋을 관리합니다.',
 ARRAY['Kafka', 'Partition', 'Consumer Group', '순서 보장', '오프셋'],
 'Partition 수로 병렬 처리량이 결정되며, 한 Partition은 그룹 내 하나의 Consumer만 처리합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '메시지 큐', 2, 10, 50,
 '메시지 전달 보장 수준의 종류를 설명하세요.',
 'At-most-once는 최대 1회 전달로 유실 가능, At-least-once는 최소 1회 전달로 중복 가능, Exactly-once는 정확히 1회 전달입니다. 비즈니스 요구에 맞게 선택해야 합니다.',
 ARRAY['At-most-once', 'At-least-once', 'Exactly-once', '메시지 전달', '중복'],
 '대부분의 시스템은 At-least-once를 사용하고, Consumer 측에서 멱등성을 보장합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '이벤트 드리븐', 2, 10, 50,
 '좋은 이벤트 설계 원칙을 설명하세요.',
 '이벤트는 과거형으로 명명(OrderCreated)하고, 불변(immutable)해야 하며, 자기 설명적(필요한 정보 포함)이어야 합니다. 버전 관리가 필요하고, 중복 처리를 고려해야 합니다.',
 ARRAY['이벤트 설계', '과거형', '불변', '버전 관리', '중복 처리'],
 '이벤트에 포함할 데이터 양은 "fat events" vs "thin events" 트레이드오프를 고려합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CQRS', 2, 10, 50,
 'Command 모델과 Query 모델의 특징을 설명하세요.',
 'Command 모델은 도메인 로직을 포함하고 정규화된 스키마로 트랜잭션을 보장합니다. Query 모델은 조회에 최적화된 비정규화 스키마로 복잡한 조인 없이 빠른 응답을 제공합니다.',
 ARRAY['Command', 'Query', '정규화', '비정규화', '도메인 로직'],
 'CQRS는 읽기/쓰기 비율 차이가 크거나 여러 뷰가 필요한 경우에 적합합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '캐싱 아키텍처', 2, 10, 50,
 'HTTP 캐시 제어 헤더의 종류와 역할을 설명하세요.',
 'Cache-Control은 캐시 정책(max-age, no-cache, private)을 지정하고, ETag는 내용 해시로 변경 여부를 확인합니다. Last-Modified는 변경 시간을 나타냅니다. 조건부 요청으로 네트워크를 절약합니다.',
 ARRAY['Cache-Control', 'ETag', 'Last-Modified', '조건부 요청', 'max-age'],
 'If-None-Match, If-Modified-Since 헤더로 조건부 요청을 보낼 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '캐싱 아키텍처', 2, 10, 50,
 '로컬 캐시와 분산 캐시의 장단점을 비교하세요.',
 '로컬 캐시는 네트워크 왕복 없이 매우 빠르지만, 인스턴스 간 불일치가 발생하고 메모리 제한이 있습니다. 분산 캐시는 인스턴스 간 공유가 가능하고 대용량 저장이 가능하지만, 네트워크 지연과 직렬화 비용이 있습니다.',
 ARRAY['로컬 캐시', '분산 캐시', '네트워크 지연', '인스턴스 불일치', 'Redis'],
 '일반적으로 L1(로컬) + L2(분산) 멀티 레이어 캐시 전략을 사용합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '스케일링', 2, 10, 50,
 '상태 비저장(Stateless) 서버가 중요한 이유를 설명하세요.',
 '상태 비저장 서버는 어떤 서버로 요청이 가도 동일하게 처리할 수 있어 서버 추가/제거가 자유롭습니다. 세션, 캐시 등 상태는 Redis 같은 외부 저장소로 분리해야 합니다.',
 ARRAY['Stateless', '상태 비저장', '수평 확장', '외부 저장소', '세션'],
 'JWT를 사용하면 클라이언트에서 상태를 관리하여 서버를 stateless로 유지할 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '스케일링', 2, 10, 50,
 'Auto Scaling의 동작 원리를 설명하세요.',
 'Auto Scaling은 CPU, 요청 수 등의 메트릭을 모니터링하여 임계값 초과 시 인스턴스를 추가하고, 임계값 미만 시 인스턴스를 제거합니다. 최소/최대 인스턴스 수와 쿨다운 기간을 설정합니다.',
 ARRAY['Auto Scaling', '메트릭', '임계값', '인스턴스', '쿨다운'],
 '급격한 변동을 방지하기 위해 쿨다운 기간을 설정하는 것이 중요합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CAP 정리', 2, 10, 50,
 'CP 시스템과 AP 시스템의 예시를 들어 설명하세요.',
 'CP 시스템은 ZooKeeper, etcd 같은 분산 코디네이터로, 네트워크 분할 시 쓰기를 거부합니다. AP 시스템은 Cassandra, DynamoDB로, 네트워크 분할에도 응답하지만 노드 간 데이터가 다를 수 있습니다.',
 ARRAY['CP', 'AP', 'ZooKeeper', 'Cassandra', '네트워크 분할'],
 'PACELC 정리는 CAP을 확장하여 정상 상태에서의 Latency vs Consistency도 고려합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '서비스 메시', 2, 10, 50,
 '서비스 메시가 제공하는 주요 기능을 설명하세요.',
 '서비스 메시는 서비스 디스커버리, 로드 밸런싱, 트래픽 제어(라우팅, 분할), 보안(mTLS), 관측성(메트릭, 트레이싱), 장애 처리(재시도, 타임아웃, 서킷 브레이커)를 제공합니다.',
 ARRAY['서비스 디스커버리', 'mTLS', '트래픽 제어', '관측성', '서킷 브레이커'],
 '사이드카 프록시를 통해 애플리케이션 코드 변경 없이 이 기능들을 적용합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '서버리스', 2, 10, 50,
 '콜드 스타트 문제와 완화 방법을 설명하세요.',
 '콜드 스타트는 함수 첫 호출 시 컨테이너 초기화로 인한 지연입니다. Provisioned Concurrency로 미리 웜업하거나, 경량 런타임(Node.js, Go) 사용, 패키지 크기 최소화, 정기적 호출로 웜 상태를 유지합니다.',
 ARRAY['콜드 스타트', 'Provisioned Concurrency', '웜업', '런타임', '지연'],
 'Java, C# 같은 무거운 런타임은 콜드 스타트가 수 초까지 걸릴 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'Circuit Breaker', 2, 10, 50,
 'Circuit Breaker의 세 가지 상태를 설명하세요.',
 'Closed는 정상 상태로 요청이 통과합니다. Open은 차단 상태로 즉시 실패를 반환합니다. Half-Open은 일부 요청으로 복구를 확인하는 상태로, 성공하면 Closed로, 실패하면 Open으로 전환됩니다.',
 ARRAY['Circuit Breaker', 'Closed', 'Open', 'Half-Open', '장애 격리'],
 '의존 서비스 장애 시 연쇄 장애를 방지하고 시스템을 보호합니다.',
 'docs/07-architecture-scalability.md'),

-- 난이도 3 (시니어) - 12문제
('architecture', '모놀리스 vs 마이크로서비스', 3, 30, 75,
 'Strangler Fig 패턴이란 무엇인가요?',
 'Strangler Fig 패턴은 모놀리스를 점진적으로 마이크로서비스로 전환하는 패턴입니다. 새 기능은 마이크로서비스로 개발하고, 기존 기능은 하나씩 추출하여 구 시스템을 점차 대체합니다.',
 ARRAY['Strangler Fig', '점진적 전환', '마이크로서비스', '모놀리스', '추출'],
 '무화과 나무가 숙주 나무를 감싸며 자라는 것에서 이름이 유래했습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API 설계', 3, 30, 75,
 'GraphQL N+1 문제와 해결 방법을 설명하세요.',
 'GraphQL N+1 문제는 관계형 데이터를 조회할 때 N개의 추가 쿼리가 발생하는 것입니다. DataLoader 패턴을 사용하여 같은 리소스에 대한 요청을 배치로 모아 한 번에 처리합니다.',
 ARRAY['GraphQL', 'N+1', 'DataLoader', '배치', '쿼리 최적화'],
 'DataLoader는 요청을 수집하여 IN 절로 한 번에 조회하는 방식으로 동작합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '메시지 큐', 3, 30, 75,
 'Dead Letter Queue(DLQ)란 무엇이고 어떻게 활용하나요?',
 'DLQ는 처리 실패한 메시지를 저장하는 별도 큐입니다. 재시도 한계 초과, 파싱 오류 등의 메시지를 분리하여 이후 분석하거나 수동으로 처리합니다. 시스템 안정성과 디버깅에 도움이 됩니다.',
 ARRAY['Dead Letter Queue', 'DLQ', '처리 실패', '재시도', '분리'],
 'DLQ의 메시지는 정기적으로 검토하고 처리해야 합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '이벤트 드리븐', 3, 30, 75,
 'Outbox 패턴이란 무엇인가요?',
 'Outbox 패턴은 DB 트랜잭션 내에서 Outbox 테이블에 이벤트를 저장하고, 별도 프로세스가 Outbox를 읽어 메시지 큐에 발행하는 패턴입니다. DB 변경과 이벤트 발행의 원자성을 보장합니다.',
 ARRAY['Outbox 패턴', '트랜잭션', '원자성', '이벤트 발행', 'Debezium'],
 'CDC(Change Data Capture)와 함께 사용하면 폴링 없이 이벤트를 캡처할 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CQRS', 3, 30, 75,
 '이벤트 소싱과 CQRS 조합의 장점을 설명하세요.',
 '이벤트가 Command 모델로 저장되고, 이벤트를 투영(Projection)하여 여러 Query 모델을 생성할 수 있습니다. 읽기 모델 재구축이 용이하고, 시간 여행 쿼리와 완전한 감사 로그가 가능합니다.',
 ARRAY['이벤트 소싱', 'CQRS', 'Projection', '재구축', '감사 로그'],
 '이벤트 스트림을 처음부터 재생하여 읽기 모델을 새로 생성할 수 있습니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '캐싱 아키텍처', 3, 30, 75,
 '캐시 워밍(Cache Warming)이란 무엇이고 언제 필요한가요?',
 '캐시 워밍은 서비스 시작 시 자주 조회되는 데이터를 미리 캐시에 로드하는 것입니다. 콜드 스타트 시 DB 부하 급증을 방지하며, 배포 직전이나 서비스 시작 시 수행합니다.',
 ARRAY['캐시 워밍', '콜드 스타트', '프리로딩', 'DB 부하', '배포'],
 '특히 트래픽이 많은 서비스에서 배포 후 성능 저하를 방지합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '스케일링', 3, 30, 75,
 'Amdahl의 법칙이란 무엇인가요?',
 'Amdahl의 법칙은 병렬화할 수 없는 부분이 전체 성능 향상의 한계를 결정한다는 것입니다. 예를 들어, 10%가 직렬 처리라면 아무리 나머지를 병렬화해도 10배 이상 빨라질 수 없습니다.',
 ARRAY['Amdahl', '병렬화', '성능 한계', '직렬', '확장성'],
 '병목점을 찾아 직렬 부분을 줄이는 것이 성능 향상의 핵심입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CAP 정리', 3, 30, 75,
 'Saga 패턴이란 무엇이고 언제 사용하나요?',
 'Saga 패턴은 분산 트랜잭션을 로컬 트랜잭션의 시퀀스로 분해하는 패턴입니다. 각 단계 실패 시 보상 트랜잭션을 실행합니다. Choreography(이벤트 체인) 또는 Orchestration(중앙 조정자) 방식이 있습니다.',
 ARRAY['Saga', '분산 트랜잭션', '보상 트랜잭션', 'Choreography', 'Orchestration'],
 '2PC의 문제점(블로킹, 확장성 제한)을 해결하기 위해 마이크로서비스에서 선호됩니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '서비스 메시', 3, 30, 75,
 '컨트롤 플레인과 데이터 플레인의 차이를 설명하세요.',
 '컨트롤 플레인은 정책 관리와 설정 배포를 담당합니다(예: Istio Pilot). 데이터 플레인은 실제 트래픽을 처리하는 프록시입니다(예: Envoy). 컨트롤 플레인이 규칙을 정의하고, 데이터 플레인이 실행합니다.',
 ARRAY['컨트롤 플레인', '데이터 플레인', 'Istio', 'Envoy', '프록시'],
 '이 분리로 확장성과 유연성을 확보합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'DDD', 3, 30, 75,
 'Anti-corruption Layer(ACL)란 무엇인가요?',
 'Anti-corruption Layer는 외부 시스템의 모델이 내부로 침투하지 않도록 변환 계층을 두는 패턴입니다. 레거시 시스템 통합이나 외부 API 통합 시 내부 도메인 모델을 보호합니다.',
 ARRAY['Anti-corruption Layer', 'ACL', '변환 계층', '레거시', '도메인 모델'],
 'Context Mapping 패턴 중 하나로, Bounded Context 간 통합에 사용됩니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'Rate Limiting', 3, 30, 75,
 '분산 환경에서 Rate Limiting을 어떻게 구현하나요?',
 '중앙 저장소(Redis)에서 카운터를 관리하고, 각 인스턴스가 Redis를 조회하여 판단합니다. INCR + EXPIRE로 카운터를 구현하거나, Lua 스크립트로 원자적 연산을 수행합니다. Sliding Window는 Sorted Set을 활용합니다.',
 ARRAY['분산 Rate Limiting', 'Redis', 'INCR', 'Lua 스크립트', 'Sliding Window'],
 '네트워크 지연과 일관성 사이의 트레이드오프를 고려해야 합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'Circuit Breaker', 3, 30, 75,
 'Retry와 Circuit Breaker를 어떻게 조합하나요?',
 'Retry → Circuit Breaker 순서로 적용합니다. 재시도 실패도 Circuit Breaker에 집계되며, Circuit이 Open이면 재시도 없이 즉시 실패합니다. Timeout도 함께 설정하여 전체 대기 시간을 제어합니다.',
 ARRAY['Retry', 'Circuit Breaker', 'Timeout', '조합', '장애 대응'],
 'Resilience4j 같은 라이브러리에서 이런 패턴을 쉽게 조합할 수 있습니다.',
 'docs/07-architecture-scalability.md'),

-- 난이도 4 (리드/CTO) - 8문제
('architecture', '모놀리스 vs 마이크로서비스', 4, 50, 100,
 'Conway의 법칙과 아키텍처의 관계를 설명하세요.',
 'Conway의 법칙은 "시스템 구조는 조직의 커뮤니케이션 구조를 반영한다"는 것입니다. 마이크로서비스 성공을 위해서는 팀을 서비스 단위로 조직하고 자율성을 부여해야 합니다. 조직 구조와 아키텍처를 함께 설계해야 합니다.',
 ARRAY['Conway 법칙', '조직 구조', '커뮤니케이션', '팀 자율성', '아키텍처'],
 'Inverse Conway Maneuver는 원하는 아키텍처에 맞게 조직을 설계하는 전략입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'API 설계', 4, 50, 100,
 'BFF(Backend For Frontend) 패턴을 설명하세요.',
 'BFF는 프론트엔드 유형(Web, Mobile, IoT)별로 전용 API 서버를 두는 패턴입니다. 각 클라이언트에 최적화된 데이터 형태와 API를 제공하며, API Gateway와 결합하여 사용합니다.',
 ARRAY['BFF', 'Backend For Frontend', '클라이언트 최적화', 'API Gateway', '프론트엔드'],
 '다양한 클라이언트가 있고 요구사항이 다를 때 효과적입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '메시지 큐', 4, 50, 100,
 '대규모 Kafka 클러스터 규모 산정 기준을 설명하세요.',
 '처리량(메시지/초), 데이터 보존 기간, 복제 팩터, 컨슈머 지연 허용치를 고려합니다. Broker 수 = (처리량 × 복제 × 보존기간) / (디스크 용량 × 처리 능력)으로 산정합니다.',
 ARRAY['Kafka', '클러스터 규모', '처리량', '복제 팩터', '용량 계획'],
 'Partition 수는 Consumer 병렬성과 순서 보장 요구사항을 고려하여 결정합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'CQRS', 4, 50, 100,
 'CQRS 안티패턴에는 어떤 것들이 있나요?',
 '모든 기능에 CQRS를 적용하는 것, 동기 이벤트로 결합도를 증가시키는 것, 거대한 단일 읽기 모델을 만드는 것, Projection 로직에 도메인 로직을 포함시키는 것 등이 안티패턴입니다.',
 ARRAY['CQRS 안티패턴', '과도한 적용', '동기 이벤트', '결합도', 'Projection'],
 '단순한 CRUD 애플리케이션에 CQRS는 과도한 설계입니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '캐싱 아키텍처', 4, 50, 100,
 '글로벌 서비스에서 캐시 전략을 어떻게 설계하나요?',
 '리전별 분산 캐시 클러스터를 운영하고, CDN 엣지에서 캐싱합니다. 리전 간 복제 또는 독립 운영을 선택하며, 캐시 미스 시 가장 가까운 리전에서 조회합니다. 일관성과 지연시간의 트레이드오프를 고려합니다.',
 ARRAY['글로벌 캐시', '리전별', 'CDN', '복제', '지연시간'],
 '캐시 용량 산정은 Working Set 크기와 히트율 목표를 기반으로 합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', '스케일링', 4, 50, 100,
 '용량 계획(Capacity Planning)은 어떻게 하나요?',
 '현재 트래픽을 분석하고 성장률을 예측합니다. 피크 트래픽을 대비하고 버퍼를 확보합니다. 정기적인 부하 테스트로 현재 용량을 파악하고, 비즈니스 팀과 협업하여 이벤트와 성장 전망을 공유받습니다.',
 ARRAY['용량 계획', '트래픽 분석', '성장률', '부하 테스트', '피크 대비'],
 'Reserved Instance로 기본 용량을 확보하고 Spot으로 피크를 처리하는 비용 최적화도 고려합니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'DDD', 4, 50, 100,
 '이벤트 스토밍(Event Storming)이란 무엇인가요?',
 '이벤트 스토밍은 도메인 전문가와 개발자가 함께 도메인 이벤트를 포스트잇으로 나열하며 도메인을 탐색하는 워크샵입니다. Bounded Context 도출, 도메인 모델 발견, 팀 공유에 효과적입니다.',
 ARRAY['이벤트 스토밍', '워크샵', 'Bounded Context', '도메인 전문가', '포스트잇'],
 'Alberto Brandolini가 고안한 기법으로, DDD 프로젝트 초기에 많이 사용됩니다.',
 'docs/07-architecture-scalability.md'),

('architecture', 'Rate Limiting', 4, 50, 100,
 'API Rate Limit 정책 설계 시 고려할 점을 설명하세요.',
 '사용자 티어별 차등 제한, 엔드포인트별 비용 차이, 버스트 허용량, 초과 시 대응(차단 vs 과금)을 고려합니다. 문서화하고 클라이언트에게 명확한 피드백(헤더, 에러 메시지)을 제공합니다.',
 ARRAY['Rate Limit 정책', '티어별', '버스트', '과금', '문서화'],
 'API 사용량 기반 과금 모델의 기초가 되며, 비즈니스 목표와 연계해야 합니다.',
 'docs/07-architecture-scalability.md'),

-- =====================================================
-- INCIDENT (장애대응/SRE) - 50문제
-- =====================================================

-- 난이도 1 (입문) - 15문제
('incident', 'SRE 원칙', 1, 1, 25,
 'SRE와 DevOps의 차이점은 무엇인가요?',
 'DevOps는 문화와 철학 중심의 광범위한 움직임이고, SRE는 그 철학을 구체적인 실천 방법과 메트릭으로 구현한 것입니다. SRE는 "DevOps를 구현하는 하나의 방법"으로 볼 수 있습니다.',
 ARRAY['SRE', 'DevOps', '문화', '메트릭', '구현'],
 'SRE는 Google에서 시작된 운영 방법론으로, 신뢰성을 측정 가능하게 만듭니다.',
 'docs/08-incident-sre.md'),

('incident', 'SRE 원칙', 1, 1, 25,
 'SRE의 핵심 목표는 무엇인가요?',
 'SRE의 핵심 목표는 시스템의 신뢰성을 측정 가능하게 만들고, 자동화를 통해 수동 운영 작업(Toil)을 줄이며, 개발 속도와 안정성 사이의 균형을 맞추는 것입니다.',
 ARRAY['SRE', '신뢰성', '자동화', 'Toil', '균형'],
 '"운영을 소프트웨어 문제로 다룬다"는 철학이 핵심입니다.',
 'docs/08-incident-sre.md'),

('incident', '온콜 운영', 1, 1, 25,
 '온콜이 필요한 이유는 무엇인가요?',
 '24/7 서비스는 언제든 장애가 발생할 수 있고, 빠른 대응이 비즈니스 영향과 사용자 경험에 직접적인 영향을 미칩니다. 업무 시간 외에도 즉각 대응할 수 있도록 교대로 대기하는 체계가 필요합니다.',
 ARRAY['온콜', '24/7', '장애 대응', '교대', '대기'],
 'PagerDuty, Opsgenie 등의 알림 시스템을 사용하여 온콜을 운영합니다.',
 'docs/08-incident-sre.md'),

('incident', '온콜 운영', 1, 1, 25,
 '온콜 담당자의 기본 책임은 무엇인가요?',
 '온콜 담당자는 알림 수신 및 응답, 초기 진단 및 완화, 에스컬레이션 판단, 장애 타임라인 기록, 핸드오프 수행 등의 책임이 있습니다.',
 ARRAY['온콜', '알림 응답', '초기 진단', '에스컬레이션', '타임라인'],
 'Primary가 응답하지 않으면 Secondary에게 자동 에스컬레이션됩니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 등급', 1, 1, 25,
 'SEV1과 SEV2의 차이점을 설명하세요.',
 'SEV1(Critical)은 전체 또는 대다수 사용자에게 영향을 미치고 핵심 비즈니스 기능이 완전히 중단된 경우입니다. SEV2(High)는 상당수 사용자에게 영향이 있지만 우회가 가능하거나, 일부 핵심 기능만 영향받는 경우입니다.',
 ARRAY['SEV1', 'SEV2', '장애 등급', '영향 범위', 'Critical'],
 '장애 등급은 적절한 대응 수준과 리소스를 할당하기 위해 필요합니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 대응', 1, 1, 25,
 '장애 대응의 5단계를 설명하세요.',
 '장애 대응은 감지(Detect) → 분류(Triage) → 완화(Mitigate) → 복구(Resolve) → 분석(Review) 단계로 구성됩니다. 감지는 장애 인지, 분류는 등급 결정, 완화는 빠른 조치, 복구는 근본 해결, 분석은 재발 방지입니다.',
 ARRAY['감지', '분류', '완화', '복구', '분석'],
 '완화는 응급 조치로 일단 서비스를 정상화하고, 복구는 근본 원인을 해결합니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 대응', 1, 1, 25,
 '완화(Mitigate)와 복구(Resolve)의 차이는 무엇인가요?',
 '완화는 롤백, 트래픽 우회 등 응급 조치로 일단 서비스를 정상화하는 것입니다. 복구는 근본 원인을 해결하여 완전히 정상화하는 것입니다. 완화를 먼저 하고, 복구는 나중에 해도 됩니다.',
 ARRAY['완화', '복구', '응급 조치', '근본 원인', '롤백'],
 '장애 상황에서는 완화로 빠르게 서비스를 정상화하는 것이 우선입니다.',
 'docs/08-incident-sre.md'),

('incident', 'Incident Commander', 1, 1, 25,
 'Incident Commander(IC)가 필요한 이유는 무엇인가요?',
 '여러 사람이 개별적으로 움직이면 혼란과 중복 작업이 발생합니다. 한 명이 전체 상황을 파악하고 조율해야 효율적인 장애 대응이 가능합니다. IC는 조율과 의사결정에 집중합니다.',
 ARRAY['Incident Commander', 'IC', '조율', '의사결정', '중앙 조율자'],
 'IC는 직접 디버깅하지 않고 전체 상황을 파악하는 역할입니다.',
 'docs/08-incident-sre.md'),

('incident', '포스트모텀', 1, 1, 25,
 'Blameless 포스트모텀이란 무엇인가요?',
 'Blameless 포스트모텀은 "누가 잘못했나"가 아니라 "시스템이 왜 이런 실수를 허용했나"에 집중하는 장애 분석입니다. 개인을 비난하지 않고 시스템 개선에 집중하여 솔직한 원인 분석과 학습이 가능합니다.',
 ARRAY['Blameless', '포스트모텀', '시스템 개선', '비난 없음', '학습'],
 '사람은 실수하므로 시스템이 실수를 방지하고 감지해야 합니다.',
 'docs/08-incident-sre.md'),

('incident', 'SLI/SLO/SLA', 1, 1, 25,
 'SLI, SLO, SLA의 차이점을 설명하세요.',
 'SLI(Service Level Indicator)는 서비스 품질 측정 지표(가용성, 지연시간 등)입니다. SLO(Service Level Objective)는 목표 수치(99.9% 가용성)입니다. SLA(Service Level Agreement)는 고객과의 계약으로 위반 시 보상이 포함됩니다.',
 ARRAY['SLI', 'SLO', 'SLA', '측정 지표', '목표', '계약'],
 'SLI를 정의하고, SLO를 설정하고, 필요시 SLA로 계약을 맺습니다.',
 'docs/08-incident-sre.md'),

('incident', 'SLI/SLO/SLA', 1, 1, 25,
 '99.9%와 99.99% 가용성의 다운타임 차이는 얼마인가요?',
 '99.9%(Three 9s)는 연간 약 8.76시간의 다운타임이 허용됩니다. 99.99%(Four 9s)는 연간 약 52.56분입니다. 9 하나를 추가하는 것은 10배 더 어렵습니다.',
 ARRAY['가용성', '99.9%', '99.99%', '다운타임', 'Three 9s'],
 '100% SLO를 목표로 하면 모든 변경이 위험해져 혁신이 멈춥니다.',
 'docs/08-incident-sre.md'),

('incident', '에러 버짓', 1, 1, 25,
 '에러 버짓이란 무엇인가요?',
 '에러 버짓은 SLO가 허용하는 장애/에러의 양을 수치화한 것입니다. 100% - SLO = 에러 버짓입니다. 예를 들어, 99.9% SLO는 0.1% 에러 버짓, 즉 월 43.2분의 다운타임을 허용합니다.',
 ARRAY['에러 버짓', 'SLO', '다운타임', '허용량', '계산'],
 '에러 버짓은 개발 속도와 안정성 사이의 객관적 균형점입니다.',
 'docs/08-incident-sre.md'),

('incident', 'Chaos Engineering', 1, 1, 25,
 'Chaos Engineering의 목적은 무엇인가요?',
 'Chaos Engineering은 실제 장애 전에 시스템의 약점을 발견하고, 시스템 회복력을 검증하며, 운영팀의 대응 연습을 하고, 시스템에 대한 가정을 검증하는 것이 목적입니다.',
 ARRAY['Chaos Engineering', '장애 주입', '회복력', '약점 발견', '검증'],
 'Netflix Chaos Monkey가 대표적인 도구입니다.',
 'docs/08-incident-sre.md'),

('incident', '런북', 1, 1, 25,
 '런북이 필요한 이유는 무엇인가요?',
 '런북은 장애 시 당황하지 않고 체계적으로 대응할 수 있게 하고, 경험이 적은 담당자도 대응 가능하게 하며, 일관된 대응 품질을 보장합니다.',
 ARRAY['런북', '장애 대응', '절차서', '일관성', '체계적'],
 '좋은 런북은 명확한 단계, 복붙 가능한 명령어, 에스컬레이션 경로를 포함합니다.',
 'docs/08-incident-sre.md'),

('incident', '재해 복구', 1, 1, 25,
 'RTO와 RPO의 차이는 무엇인가요?',
 'RTO(Recovery Time Objective)는 "얼마나 빨리 복구해야 하는가"로 복구 목표 시간입니다. RPO(Recovery Point Objective)는 "얼마나 많은 데이터 손실을 감수할 수 있는가"로 데이터 손실 허용 시점입니다.',
 ARRAY['RTO', 'RPO', '복구 시간', '데이터 손실', '재해 복구'],
 'RTO 1시간, RPO 15분이면 1시간 내 복구하고 최대 15분치 데이터 손실을 허용합니다.',
 'docs/08-incident-sre.md'),

-- 난이도 2 (주니어) - 15문제
('incident', 'SRE 원칙', 2, 10, 50,
 '50% 규칙이 중요한 이유는 무엇인가요?',
 'SRE 시간의 50% 이상을 엔지니어링 작업에 투자해야 합니다. Toil이 50%를 넘으면 자동화할 시간이 없어져 악순환에 빠집니다. 엔지니어링 시간을 확보해야 장기적으로 운영 부담이 줄어듭니다.',
 ARRAY['50% 규칙', 'Toil', '엔지니어링', '자동화', '악순환'],
 'SRE는 운영을 소프트웨어 문제로 다루어 자동화로 해결합니다.',
 'docs/08-incident-sre.md'),

('incident', '온콜 운영', 2, 10, 50,
 '효과적인 온콜 핸드오프 방법을 설명하세요.',
 '현재 진행 중인 이슈 상태를 문서화하고, 주의해야 할 알림이나 트렌드를 공유합니다. 예정된 변경사항을 알리고, 구두나 비동기로 직접 소통하여 인계합니다.',
 ARRAY['핸드오프', '문서화', '이슈 상태', '트렌드', '인계'],
 '장시간 장애 시 IC 인수인계도 마찬가지로 현재 상황을 명확히 전달해야 합니다.',
 'docs/08-incident-sre.md'),

('incident', '온콜 운영', 2, 10, 50,
 '알림 피로(Alert Fatigue)를 줄이는 방법을 설명하세요.',
 '불필요한 알림을 제거하고, 알림을 그룹화하며, 임계값을 튜닝합니다. 자동 복구를 구현하고, 정보성 알림과 긴급 알림을 분리합니다.',
 ARRAY['알림 피로', 'Alert Fatigue', '알림 튜닝', '자동 복구', '그룹화'],
 '알림이 너무 많으면 중요한 알림을 놓칠 수 있습니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 등급', 2, 10, 50,
 'SEV 등급별 일반적인 대응 SLA를 설명하세요.',
 'SEV1은 15분 내 응답, 4시간 내 완화가 목표입니다. SEV2는 30분 내 응답, 8시간 내 완화입니다. SEV3는 4시간 내 응답, 24시간 내 해결입니다. SEV4는 24시간 내 응답입니다.',
 ARRAY['SEV', '응답 SLA', '완화 시간', '해결 시간', '대응'],
 '장애 등급을 잘못 판단했으면 언제든 조정할 수 있으며, 과소평가보다 과대평가가 낫습니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 대응', 2, 10, 50,
 '장애 타임라인에 기록해야 할 내용은 무엇인가요?',
 '장애 인지 시점, 주요 발견사항, 시도한 조치와 결과, 에스컬레이션, 완화/복구 시점, 의사결정과 근거를 타임스탬프와 함께 기록합니다.',
 ARRAY['타임라인', '기록', '발견사항', '조치', '의사결정'],
 '타임라인은 포스트모텀의 기초 자료가 됩니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 대응', 2, 10, 50,
 '워룸(War Room)의 기본 규칙을 설명하세요.',
 '역할을 명확히 하고(IC, 커뮤니케이터, 기록자), 관련 없는 대화를 금지합니다. 행동 전 의도를 공유하고, 발견 즉시 공유하며, 정기적으로 상태를 요약합니다.',
 ARRAY['워룸', 'War Room', '역할', 'IC', '커뮤니케이션'],
 '워룸은 장애 대응을 위한 집중 커뮤니케이션 채널입니다.',
 'docs/08-incident-sre.md'),

('incident', 'Incident Commander', 2, 10, 50,
 'Communications Lead와 Scribe의 역할을 설명하세요.',
 'Communications Lead는 외부 커뮤니케이션을 담당하여 상태 페이지 업데이트, 고객 알림, 경영진 보고를 합니다. Scribe(기록자)는 실시간으로 타임라인을 기록하고 주요 발견과 조치를 문서화합니다.',
 ARRAY['Communications Lead', 'Scribe', '기록자', '상태 페이지', '타임라인'],
 'IC가 기술적 조율에 집중할 수 있도록 역할을 분담합니다.',
 'docs/08-incident-sre.md'),

('incident', '포스트모텀', 2, 10, 50,
 '5 Whys 기법은 어떻게 적용하나요?',
 '"왜 이런 일이 발생했나?"를 반복하여 표면적 원인에서 근본 원인까지 도달합니다. 반드시 5회일 필요는 없고, 여러 분기로 나뉠 수 있습니다.',
 ARRAY['5 Whys', '근본 원인', '반복', '분석', '원인 도출'],
 '예: 서버 다운 → 메모리 부족 → 메모리 누수 → 코드 버그 → 테스트 부재',
 'docs/08-incident-sre.md'),

('incident', '포스트모텀', 2, 10, 50,
 '좋은 액션 아이템의 조건을 설명하세요.',
 '좋은 액션 아이템은 구체적(무엇을), 측정 가능하고, 담당자가 지정되어 있으며, 기한이 설정되어 있고, 추적 가능해야 합니다. "모니터링 개선"이 아니라 "API 응답시간 알림 임계값 500ms로 조정 by 3/15"처럼 작성합니다.',
 ARRAY['액션 아이템', '구체적', '측정 가능', '담당자', '기한'],
 '액션 아이템 완료율을 정기적으로 추적해야 합니다.',
 'docs/08-incident-sre.md'),

('incident', 'SLI/SLO/SLA', 2, 10, 50,
 '지연시간 SLI에서 평균 대신 백분위수를 사용하는 이유를 설명하세요.',
 '평균은 이상치에 왜곡되기 쉽습니다. p50(중앙값), p90, p99를 사용하면 사용자 경험을 더 정확하게 반영합니다. 특히 p99는 "최악의 케이스" 사용자 경험을 나타냅니다.',
 ARRAY['지연시간', '백분위수', 'p99', 'p50', '평균'],
 '대부분의 사용자가 좋은 경험을 해도 일부가 나쁘면 SLO를 달성하지 못할 수 있습니다.',
 'docs/08-incident-sre.md'),

('incident', '에러 버짓', 2, 10, 50,
 '에러 버짓 계산 예시를 설명하세요.',
 '월간 100만 요청에 SLO 99.9%면 에러 버짓은 1000 실패 요청입니다. 현재까지 300 실패라면 30% 소진, 70% 잔여입니다. 버짓을 빠르게 소진하고 있다면 신규 배포를 중단하고 안정화 작업을 우선합니다.',
 ARRAY['에러 버짓', '계산', '실패 요청', '소진율', '안정화'],
 '에러 버짓은 개발팀과 운영팀의 객관적 협력 기준입니다.',
 'docs/08-incident-sre.md'),

('incident', 'Chaos Engineering', 2, 10, 50,
 'Chaos 실험 전 필요한 준비를 설명하세요.',
 'Steady State(정상 메트릭)를 정의하고, 롤백 계획을 수립합니다. 영향 범위를 제한하고, 모니터링을 준비하며, 이해관계자에게 알립니다.',
 ARRAY['Chaos Engineering', 'Steady State', '롤백', '영향 범위', '모니터링'],
 'Blast Radius를 제한하여 일부 인스턴스/사용자만 대상으로 합니다.',
 'docs/08-incident-sre.md'),

('incident', '카나리 분석', 2, 10, 50,
 '카나리 트래픽 비율과 분석 기간은 어떻게 결정하나요?',
 '트래픽 비율은 보통 1-5%로 시작하여 통계적 유의성을 확보하면서 문제 시 영향을 최소화합니다. 분석 기간은 최소 15-30분, 이상적으로 1-2시간이며, 트래픽 패턴과 지연 문제(메모리 누수 등)를 고려합니다.',
 ARRAY['카나리', '트래픽 비율', '분석 기간', '통계적 유의성', '영향 최소화'],
 '베이스라인과 같은 시점에 비교해야 정확한 분석이 가능합니다.',
 'docs/08-incident-sre.md'),

('incident', '런북', 2, 10, 50,
 '런북에 포함되어야 할 필수 항목을 설명하세요.',
 '알림 의미, 영향 범위, 진단 명령어/방법, 해결 절차, 확인 방법, 에스컬레이션 기준 및 연락처, 관련 문서 링크가 포함되어야 합니다.',
 ARRAY['런북', '진단', '해결 절차', '에스컬레이션', '알림'],
 '의사결정 트리로 상황별 분기 처리를 시각화하면 좋습니다.',
 'docs/08-incident-sre.md'),

('incident', '재해 복구', 2, 10, 50,
 'DR 전략별 비용과 RTO 관계를 설명하세요.',
 'Backup/Restore < Pilot Light < Warm Standby < Multi-Site 순으로 비용이 증가하고 RTO가 감소합니다. Pilot Light는 핵심 시스템만 최소 규모로 DR 환경에서 실행하여 비용과 RTO의 균형을 맞춥니다.',
 ARRAY['DR 전략', 'Backup', 'Pilot Light', 'Warm Standby', 'Multi-Site'],
 '비즈니스 요구와 비용을 고려하여 적절한 전략을 선택합니다.',
 'docs/08-incident-sre.md'),

-- 난이도 3 (시니어) - 12문제
('incident', 'SRE 원칙', 3, 30, 75,
 'Production Readiness Review에 포함되어야 할 항목을 설명하세요.',
 '아키텍처 검토, 장애 시나리오, 모니터링/알림, SLO 정의, 온콜 런북, 의존성 분석, 용량 계획, 보안 검토, 데이터 백업/복구 계획이 포함되어야 합니다.',
 ARRAY['Production Readiness', '아키텍처', '모니터링', 'SLO', '런북'],
 'SRE가 서비스를 지원하기 전에 이 검토를 통해 준비 상태를 확인합니다.',
 'docs/08-incident-sre.md'),

('incident', '온콜 운영', 3, 30, 75,
 '건강한 온콜 로테이션 설계 원칙을 설명하세요.',
 '최소 8명 이상의 풀로 주 1회 이하 온콜을 유지하고, 연속 온콜을 금지합니다. 공휴일을 균등하게 분배하고, 긴급 호출 횟수를 모니터링하며, 온콜 부담을 측정하고 조정합니다.',
 ARRAY['온콜 로테이션', '8명', '공휴일', '부담 측정', '균등 분배'],
 '온콜 효과성은 알림 횟수, MTTR, False Positive 비율 등으로 측정합니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 등급', 3, 30, 75,
 '비즈니스 임팩트를 정량화하는 방법을 설명하세요.',
 '분당/시간당 매출 손실, 영향받는 고객 수, SLA 위반 페널티, 규정 위반 벌금, 복구 비용, 평판 손상을 추정하여 정량화합니다.',
 ARRAY['비즈니스 임팩트', '매출 손실', 'SLA 위반', '고객 수', '정량화'],
 '동시에 여러 장애가 발생하면 가장 높은 SEV에 집중합니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 대응', 3, 30, 75,
 '장애 종료 조건은 무엇인가요?',
 '고객 영향이 제거되고, 메트릭이 정상화되며, 근본 원인이 파악(해결은 아니어도 됨)되고, 추가 조치가 불필요할 때 장애를 종료합니다. 모니터링 강화 후 종료합니다.',
 ARRAY['장애 종료', '고객 영향', '메트릭 정상화', '근본 원인', '모니터링'],
 '복구 시간 예측이 어려우면 "조사 중"으로 시작하고 원인 파악 시 업데이트합니다.',
 'docs/08-incident-sre.md'),

('incident', 'Incident Commander', 3, 30, 75,
 'IC가 기술적으로 깊이 관여하면 안 되는 이유를 설명하세요.',
 'IC가 특정 문제에 몰입하면 전체 상황 파악이 어려워집니다. IC는 헬리콥터 뷰를 유지해야 하며, 기술적 문제 해결은 Subject Matter Expert에게 맡기고 조율과 의사결정에 집중해야 합니다.',
 ARRAY['IC', '헬리콥터 뷰', '조율', '의사결정', '전체 상황'],
 '결정하기 어려운 상황에서도 가용한 정보로 최선의 판단을 하고, 잘못되면 즉시 수정합니다.',
 'docs/08-incident-sre.md'),

('incident', '포스트모텀', 3, 30, 75,
 '포스트모텀 액션 아이템 완료율을 높이는 방법을 설명하세요.',
 '정기적 추적 미팅을 하고, 백로그에 통합하며, 우선순위를 지정합니다. 경영진 리뷰를 하고, 완료율을 메트릭화하며, 미완료 시 원인을 분석합니다.',
 ARRAY['액션 아이템', '완료율', '추적', '백로그', '메트릭'],
 '포스트모텀의 가치는 액션 아이템 이행에서 나옵니다.',
 'docs/08-incident-sre.md'),

('incident', 'SLI/SLO/SLA', 3, 30, 75,
 '에러 버짓 소진율(Burn Rate) 기반 알림이란 무엇인가요?',
 '"현재 속도로 에러가 발생하면 SLO를 언제 위반하는가"를 계산합니다. 예를 들어, 1시간에 30일 버짓의 2%를 소진하면 긴급 알림, 6시간에 5%면 경고 알림을 발생시킵니다.',
 ARRAY['Burn Rate', '소진율', 'SLO', '알림', '경고'],
 'Multi-window, Multi-burn-rate 알림으로 더 정교한 전략을 구현합니다.',
 'docs/08-incident-sre.md'),

('incident', '에러 버짓', 3, 30, 75,
 '에러 버짓 정책의 예시를 설명하세요.',
 '버짓 50% 소진 시 신규 기능 배포 검토를 강화합니다. 75% 소진 시 신규 배포를 중단하고 안정화에 집중합니다. 100% 소진 시 기능 동결하고 버짓 복구까지 기다립니다.',
 ARRAY['에러 버짓 정책', '배포 중단', '안정화', '기능 동결', '버짓 복구'],
 '에러 버짓 정책은 개발팀과 함께 수립해야 합니다.',
 'docs/08-incident-sre.md'),

('incident', 'Chaos Engineering', 3, 30, 75,
 'GameDay 진행 방법을 설명하세요.',
 '1) 시나리오 설계 2) 역할 배정(공격팀/방어팀) 3) 모니터링 준비 4) 장애 주입 5) 대응 관찰 6) 디브리핑 7) 개선점 도출 순서로 진행합니다.',
 ARRAY['GameDay', '시나리오', '공격팀', '방어팀', '디브리핑'],
 '과거 장애 재현, 의존성 장애, 급격한 트래픽 증가 등의 시나리오를 실험합니다.',
 'docs/08-incident-sre.md'),

('incident', '카나리 분석', 3, 30, 75,
 '카나리 분석이 Pass했지만 문제가 발생하면 어떻게 해야 하나요?',
 '메트릭 커버리지가 부족하거나 SLI에 포함되지 않은 문제일 수 있습니다. 분석 기간이 부족했을 수도 있습니다. 포스트모텀에서 분석하고 메트릭과 분석 방법을 개선합니다.',
 ARRAY['카나리', 'False Negative', '메트릭 커버리지', 'SLI', '개선'],
 '비즈니스 메트릭(전환율 등)도 카나리 분석에 포함하는 것이 좋습니다.',
 'docs/08-incident-sre.md'),

('incident', '런북', 3, 30, 75,
 '런북을 자동화하는 방법을 설명하세요.',
 '진단 스크립트를 작성하고, 원클릭 복구 도구를 만듭니다. PagerDuty, Rundeck 등 런북 자동화 플랫폼을 사용하고, ChatOps와 통합합니다.',
 ARRAY['런북 자동화', '진단 스크립트', 'Rundeck', 'ChatOps', '원클릭 복구'],
 '런북이 outdated되지 않도록 포스트모텀 액션에 런북 업데이트를 포함합니다.',
 'docs/08-incident-sre.md'),

('incident', '재해 복구', 3, 30, 75,
 '동기 vs 비동기 데이터 복제의 트레이드오프를 설명하세요.',
 '동기 복제는 RPO=0으로 데이터 손실이 없지만 지연시간이 증가합니다. 비동기 복제는 성능이 좋지만 복제 지연만큼 데이터 손실이 가능합니다. 비즈니스 요구에 맞게 선택합니다.',
 ARRAY['동기 복제', '비동기 복제', 'RPO', '지연시간', '데이터 손실'],
 '페일오버 테스트는 최소 연 1회, 이상적으로 분기 1회 수행합니다.',
 'docs/08-incident-sre.md'),

-- 난이도 4 (리드/CTO) - 8문제
('incident', 'SRE 원칙', 4, 50, 100,
 '조직에 SRE 문화를 도입하는 전략을 설명하세요.',
 '1) 파일럿 팀에서 성공 사례를 만들고 2) SLO 기반 대화 문화를 조성합니다. 3) 포스트모텀 공유를 장려하고 4) Toil을 측정하고 가시화합니다. 5) 경영진 지원을 확보하고 6) 교육 프로그램을 운영합니다.',
 ARRAY['SRE 문화', '도입 전략', 'SLO', '포스트모텀', 'Toil'],
 'SRE 투자 ROI는 장애 비용 감소, MTTR 개선, 개발자 생산성 향상으로 측정합니다.',
 'docs/08-incident-sre.md'),

('incident', '온콜 운영', 4, 50, 100,
 'Follow-the-Sun 모델의 장단점을 설명하세요.',
 '장점은 야간 온콜이 없어 삶의 질이 향상됩니다. 단점은 팀 간 조율이 복잡하고, 지식이 분산되며, 핸드오프 오버헤드가 있습니다. 최소 3개 이상 시간대에 팀이 필요합니다.',
 ARRAY['Follow-the-Sun', '글로벌', '야간 온콜', '핸드오프', '시간대'],
 '완전한 무온콜은 어렵지만 온콜 부담을 최소화하는 것은 가능합니다.',
 'docs/08-incident-sre.md'),

('incident', '장애 대응', 4, 50, 100,
 '장애 대응 성숙도를 높이는 방법을 설명하세요.',
 '1) 문서화된 프로세스 2) 정기 훈련 3) 포스트모텀 문화 4) 자동화된 도구 5) 명확한 역할 정의 6) 경험 공유 세션을 통해 성숙도를 높입니다.',
 ARRAY['장애 대응 성숙도', '프로세스', '훈련', '자동화', '역할 정의'],
 '비상 대응 훈련을 정기적으로 수행하여 실전 대응 역량을 향상시킵니다.',
 'docs/08-incident-sre.md'),

('incident', '포스트모텀', 4, 50, 100,
 '포스트모텀 문화가 정착되지 않는 원인과 해결 방법을 설명하세요.',
 '원인은 비난 문화, 시간 부족, 경영진 무관심, 액션 미이행, 형식적 진행입니다. 해결을 위해 리더십의 명시적 지지와 모범이 필요하고, 학습을 극대화하기 위해 전사 공유 세션과 신규 입사자 온보딩에 활용합니다.',
 ARRAY['포스트모텀 문화', '비난 문화', '리더십', '학습', '공유'],
 '포스트모텀 문화는 심리적 안전감과 학습 조직의 기반입니다.',
 'docs/08-incident-sre.md'),

('incident', 'SLI/SLO/SLA', 4, 50, 100,
 'SLO를 비즈니스 목표와 연계하는 방법을 설명하세요.',
 '가용성 99.9%에서 99.99%로 올리면 매출 X% 증가, 고객 이탈 Y% 감소 등을 정량화합니다. 신뢰성 투자의 ROI를 측정하여 비즈니스 의사결정에 반영합니다.',
 ARRAY['SLO', '비즈니스 목표', 'ROI', '정량화', '투자'],
 'SLA 협상 시에는 SLO보다 낮은 SLA를 설정하여 버퍼를 확보합니다.',
 'docs/08-incident-sre.md'),

('incident', '에러 버짓', 4, 50, 100,
 '에러 버짓 문화의 조직적 이점을 설명하세요.',
 '개발팀과 운영팀 간 갈등을 해소하고, 객관적 의사결정 기준을 제공합니다. 신뢰성 투자를 정당화하고, 리스크를 정량화합니다. 버짓 내에서 빠른 개발, 소진 시 안정화 우선이라는 명확한 규칙을 제공합니다.',
 ARRAY['에러 버짓 문화', '갈등 해소', '의사결정', '리스크 정량화', '협력'],
 '비즈니스 이벤트(블랙프라이데이 등) 전에는 버짓을 충분히 확보해야 합니다.',
 'docs/08-incident-sre.md'),

('incident', 'Chaos Engineering', 4, 50, 100,
 '조직에 Chaos Engineering을 도입하는 전략을 설명하세요.',
 '1) 작은 규모로 시작 2) 성공 사례 공유 3) 점진적 확대 4) 도구 표준화 5) 교육 6) 경영진 지지 확보 순서로 도입합니다. 규제 환경에서는 규제 기관 사전 협의, 문서화된 절차, 비프로덕션 환경 우선이 필요합니다.',
 ARRAY['Chaos Engineering 도입', '점진적', '경영진 지지', '규제 환경', '표준화'],
 'Chaos Engineering 성숙도: Ad-hoc → 정기적 → 프로덕션 → CI/CD 통합 → 지속적',
 'docs/08-incident-sre.md'),

('incident', '재해 복구', 4, 50, 100,
 'DR 투자 비용을 정당화하는 방법을 설명하세요.',
 '장애 시 비용(시간당 손실 × 예상 다운타임), 규정 위반 페널티, 평판 손상, 고객 이탈 비용을 DR 구축/운영 비용과 비교합니다. 금융/의료 등 규제 산업에서는 명시적 RTO/RPO와 정기 테스트가 필수입니다.',
 ARRAY['DR 비용', '정당화', '장애 비용', '규정 준수', 'ROI'],
 '글로벌 아키텍처 설계 시 데이터 주권 규정(GDPR 등)도 고려해야 합니다.',
 'docs/08-incident-sre.md');
